-- Copyright 2023 The Yock Authors. All rights reserved.
-- Use of this source code is governed by a MIT-style
-- license that can be found in the LICENSE file.

---@meta _

---ffi allows yock open and call dynamic library.
---@class ffiLib
---@field lib table
ffi = {}

---library declares function prototype (arguments +
---return value type) and creates its at running.
---Then, you can call its as function through
---ffi.lib.'lib_name'.'function_name' format.
---
---### Type corresponding:
---```
---Lua      | C
-------------------
---         |void
---integer  |uint8
---integer  |int8
---integer  |uint16
---integer  |int16
---integer  |uint32
---integer  |int32
---integer  |uint64
---integer  |int64
---integer  |int (int32)
---integer  |long (int64)
---number   |float
---number   |double
---boolean  |bool
---string   |str (ptr type alias)
---userdata |ptr # pointer type
---```
---
---### Example:
---```lua
---# declares function prototype, and it's worth noting filename extension isn't required,
---# and yock will refer extension's name to add it automatically
---# according to platform (windows: .dll, linux: .so, darwin: .dylib).
---# Of course, obvious to add it is allowed, but not recommended because it's considered
---# difficult to cross platform.
---ffi.library("./lib/mylib", {
---     hello = { "void", { "str" } }
---})
---
---# calls function, no matter how tortuous the library path is, and yock only extracts filename
---# in the end of path, meanwhile to split filename extension (.dll, .so, .dylib) to ensure cross platform.
---ffi.lib.mylib.hello("yock")
---```
---@param lib string
---@param funcs table
function ffi.library(lib, funcs) end
