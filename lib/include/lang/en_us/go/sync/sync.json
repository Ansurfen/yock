{
	"syncCondBroadcast": "--- Broadcast wakes all goroutines waiting on c.\n---\n--- It is allowed but not required for the caller to hold c.L\n--- during the call.",
	"syncCondSignal": "--- Signal wakes one goroutine waiting on c, if there is any.\n---\n--- It is allowed but not required for the caller to hold c.L\n--- during the call.\n---\n--- Signal() does not affect goroutine scheduling priority; if other goroutines\n--- are attempting to lock c.L, they may be awoken before a \"waiting\" goroutine.",
	"syncCondWait": "--- Wait atomically unlocks c.L and suspends execution\n--- of the calling goroutine. After later resuming execution,\n--- Wait locks c.L before returning. Unlike in other systems,\n--- Wait cannot return unless awoken by Broadcast or Signal.\n---\n--- Because c.L is not locked while Wait is waiting, the caller\n--- typically cannot assume that the condition is true when\n--- Wait returns. Instead, the caller should Wait in a loop:\n---\n---\tc.L.Lock()\n---\tfor !condition() {\n---\t    c.Wait()\n---\t}\n---\t... make use of condition ...\n---\tc.L.Unlock()",
	"syncMapCompareAndDelete": "--- CompareAndDelete deletes the entry for key if its value is equal to old.\n--- The old value must be of a comparable type.\n---\n--- If there is no current value for key in the map, CompareAndDelete\n--- returns false (even if the old value is the nil interface value).",
	"syncMapCompareAndSwap": "--- CompareAndSwap swaps the old and new values for key\n--- if the value stored in the map is equal to old.\n--- The old value must be of a comparable type.",
	"syncMapDelete": "--- Delete deletes the value for a key.",
	"syncMapLoad": "--- Load returns the value stored in the map for a key, or nil if no\n--- value is present.\n--- The ok result indicates whether value was found in the map.",
	"syncMapLoadAndDelete": "--- LoadAndDelete deletes the value for a key, returning the previous value if any.\n--- The loaded result reports whether the key was present.",
	"syncMapLoadOrStore": "--- LoadOrStore returns the existing value for the key if present.\n--- Otherwise, it stores and returns the given value.\n--- The loaded result is true if the value was loaded, false if stored.",
	"syncMapRange": "--- Range calls f sequentially for each key and value present in the map.\n--- If f returns false, range stops the iteration.\n---\n--- Range does not necessarily correspond to any consistent snapshot of the Map's\n--- contents: no key will be visited more than once, but if the value for any key\n--- is stored or deleted concurrently (including by f), Range may reflect any\n--- mapping for that key from any point during the Range call. Range does not\n--- block other methods on the receiver; even f itself may call any method on m.\n---\n--- Range may be O(N) with the number of elements in the map even if f returns\n--- false after a constant number of calls.",
	"syncMapStore": "--- Store sets the value for a key.",
	"syncMapSwap": "--- Swap swaps the value for a key and returns the previous value if any.\n--- The loaded result reports whether the key was present.",
	"syncMapdirtyLocked": "",
	"syncMaploadReadOnly": "",
	"syncMapmissLocked": "",
	"syncMutexLock": "--- Lock locks m.\n--- If the lock is already in use, the calling goroutine\n--- blocks until the mutex is available.",
	"syncMutexTryLock": "--- TryLock tries to lock m and reports whether it succeeded.\n---\n--- Note that while correct uses of TryLock do exist, they are rare,\n--- and use of TryLock is often a sign of a deeper problem\n--- in a particular use of mutexes.",
	"syncMutexUnlock": "--- Unlock unlocks m.\n--- It is a run-time error if m is not locked on entry to Unlock.\n---\n--- A locked Mutex is not associated with a particular goroutine.\n--- It is allowed for one goroutine to lock a Mutex and then\n--- arrange for another goroutine to unlock it.",
	"syncMutexlockSlow": "",
	"syncMutexunlockSlow": "",
	"syncNewCond": "--- NewCond returns a new Cond with Locker l.",
	"syncOnceDo": "--- Do calls the function f if and only if Do is being called for the\n--- first time for this instance of Once. In other words, given\n---\n---\tvar once Once\n---\n--- if once.Do(f) is called multiple times, only the first call will invoke f,\n--- even if f has a different value in each invocation. A new instance of\n--- Once is required for each function to execute.\n---\n--- Do is intended for initialization that must be run exactly once. Since f\n--- is niladic, it may be necessary to use a function literal to capture the\n--- arguments to a function to be invoked by Do:\n---\n---\tconfig.once.Do(func() { config.init(filename) })\n---\n--- Because no call to Do returns until the one call to f returns, if f causes\n--- Do to be called, it will deadlock.\n---\n--- If f panics, Do considers it to have returned; future calls of Do return\n--- without calling f.",
	"syncOncedoSlow": "",
	"syncPoolGet": "--- Get selects an arbitrary item from the Pool, removes it from the\n--- Pool, and returns it to the caller.\n--- Get may choose to ignore the pool and treat it as empty.\n--- Callers should not assume any relation between values passed to Put and\n--- the values returned by Get.\n---\n--- If Get would otherwise return nil and p.New is non-nil, Get returns\n--- the result of calling p.New.",
	"syncPoolPut": "--- Put adds x to the pool.",
	"syncPoolgetSlow": "",
	"syncPoolpin": "--- pin pins the current goroutine to P, disables preemption and\n--- returns poolLocal pool for the P and the P's id.\n--- Caller must call runtime_procUnpin() when done with the pool.",
	"syncPoolpinSlow": "",
	"syncRWMutexLock": "--- Lock locks rw for writing.\n--- If the lock is already locked for reading or writing,\n--- Lock blocks until the lock is available.",
	"syncRWMutexRLock": "--- RLock locks rw for reading.\n---\n--- It should not be used for recursive read locking; a blocked Lock\n--- call excludes new readers from acquiring the lock. See the\n--- documentation on the RWMutex type.",
	"syncRWMutexRLocker": "--- RLocker returns a Locker interface that implements\n--- the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.",
	"syncRWMutexRUnlock": "--- RUnlock undoes a single RLock call;\n--- it does not affect other simultaneous readers.\n--- It is a run-time error if rw is not locked for reading\n--- on entry to RUnlock.",
	"syncRWMutexTryLock": "--- TryLock tries to lock rw for writing and reports whether it succeeded.\n---\n--- Note that while correct uses of TryLock do exist, they are rare,\n--- and use of TryLock is often a sign of a deeper problem\n--- in a particular use of mutexes.",
	"syncRWMutexTryRLock": "--- TryRLock tries to lock rw for reading and reports whether it succeeded.\n---\n--- Note that while correct uses of TryRLock do exist, they are rare,\n--- and use of TryRLock is often a sign of a deeper problem\n--- in a particular use of mutexes.",
	"syncRWMutexUnlock": "--- Unlock unlocks rw for writing. It is a run-time error if rw is\n--- not locked for writing on entry to Unlock.\n---\n--- As with Mutexes, a locked RWMutex is not associated with a particular\n--- goroutine. One goroutine may RLock (Lock) a RWMutex and then\n--- arrange for another goroutine to RUnlock (Unlock) it.",
	"syncRWMutexrUnlockSlow": "",
	"syncWaitGroupAdd": "--- Add adds delta, which may be negative, to the WaitGroup counter.\n--- If the counter becomes zero, all goroutines blocked on Wait are released.\n--- If the counter goes negative, Add panics.\n---\n--- Note that calls with a positive delta that occur when the counter is zero\n--- must happen before a Wait. Calls with a negative delta, or calls with a\n--- positive delta that start when the counter is greater than zero, may happen\n--- at any time.\n--- Typically this means the calls to Add should execute before the statement\n--- creating the goroutine or other event to be waited for.\n--- If a WaitGroup is reused to wait for several independent sets of events,\n--- new Add calls must happen after all previous Wait calls have returned.\n--- See the WaitGroup example.",
	"syncWaitGroupDone": "--- Done decrements the WaitGroup counter by one.",
	"syncWaitGroupWait": "--- Wait blocks until the WaitGroup counter is zero."
}