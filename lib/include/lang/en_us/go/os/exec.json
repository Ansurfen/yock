{
	"execCmdCombinedOutput": "--- CombinedOutput runs the command and returns its combined standard\n--- output and standard error.",
	"execCmdEnviron": "--- Environ returns a copy of the environment in which the command would be run\n--- as it is currently configured.",
	"execCmdOutput": "--- Output runs the command and returns its standard output.\n--- Any returned error will usually be of type *ExitError.\n--- If c.Stderr was nil, Output populates ExitError.Stderr.",
	"execCmdRun": "--- Run starts the specified command and waits for it to complete.\n---\n--- The returned error is nil if the command runs, has no problems\n--- copying stdin, stdout, and stderr, and exits with a zero exit\n--- status.\n---\n--- If the command starts but does not complete successfully, the error is of\n--- type *ExitError. Other error types may be returned for other situations.\n---\n--- If the calling goroutine has locked the operating system thread\n--- with runtime.LockOSThread and modified any inheritable OS-level\n--- thread state (for example, Linux or Plan 9 name spaces), the new\n--- process will inherit the caller's thread state.",
	"execCmdStart": "--- Start starts the specified command but does not wait for it to complete.\n---\n--- If Start returns successfully, the c.Process field will be set.\n---\n--- After a successful call to Start the Wait method must be called in\n--- order to release associated system resources.",
	"execCmdStderrPipe": "--- StderrPipe returns a pipe that will be connected to the command's\n--- standard error when the command starts.\n---\n--- Wait will close the pipe after seeing the command exit, so most callers\n--- need not close the pipe themselves. It is thus incorrect to call Wait\n--- before all reads from the pipe have completed.\n--- For the same reason, it is incorrect to use Run when using StderrPipe.\n--- See the StdoutPipe example for idiomatic usage.",
	"execCmdStdinPipe": "--- StdinPipe returns a pipe that will be connected to the command's\n--- standard input when the command starts.\n--- The pipe will be closed automatically after Wait sees the command exit.\n--- A caller need only call Close to force the pipe to close sooner.\n--- For example, if the command being run will not exit until standard input\n--- is closed, the caller must close the pipe.",
	"execCmdStdoutPipe": "--- StdoutPipe returns a pipe that will be connected to the command's\n--- standard output when the command starts.\n---\n--- Wait will close the pipe after seeing the command exit, so most callers\n--- need not close the pipe themselves. It is thus incorrect to call Wait\n--- before all reads from the pipe have completed.\n--- For the same reason, it is incorrect to call Run when using StdoutPipe.\n--- See the example for idiomatic usage.",
	"execCmdString": "--- String returns a human-readable description of c.\n--- It is intended only for debugging.\n--- In particular, it is not suitable for use as input to a shell.\n--- The output of String may vary across Go releases.",
	"execCmdWait": "--- Wait waits for the command to exit and waits for any copying to\n--- stdin or copying from stdout or stderr to complete.\n---\n--- The command must have been started by Start.\n---\n--- The returned error is nil if the command runs, has no problems\n--- copying stdin, stdout, and stderr, and exits with a zero exit\n--- status.\n---\n--- If the command fails to run or doesn't complete successfully, the\n--- error is of type *ExitError. Other error types may be\n--- returned for I/O problems.\n---\n--- If any of c.Stdin, c.Stdout or c.Stderr are not an *os.File, Wait also waits\n--- for the respective I/O loop copying to or from the process to complete.\n---\n--- Wait releases any resources associated with the Cmd.",
	"execCmdargv": "",
	"execCmdawaitGoroutines": "--- awaitGoroutines waits for the results of the goroutines copying data to or\n--- from the command's I/O pipes.\n---\n--- If c.WaitDelay elapses before the goroutines complete, awaitGoroutines\n--- forcibly closes their pipes and returns ErrWaitDelay.\n---\n--- If timer is non-nil, it must send to timer.C at the end of c.WaitDelay.",
	"execCmdchildStderr": "",
	"execCmdchildStdin": "",
	"execCmdchildStdout": "",
	"execCmdenviron": "--- environ returns a best-effort copy of the environment in which the command\n--- would be run as it is currently configured. If an error occurs in computing\n--- the environment, it is returned alongside the best-effort copy.",
	"execCmdwatchCtx": "--- watchCtx watches c.ctx until it is able to send a result to resultc.\n---\n--- If c.ctx is done before a result can be sent, watchCtx calls c.Cancel,\n--- and/or kills cmd.Process it after c.WaitDelay has elapsed.\n---\n--- watchCtx manipulates c.goroutineErr, so its result must be received before\n--- c.awaitGoroutines is called.",
	"execCmdwriterDescriptor": "--- writerDescriptor returns an os.File to which the child process\n--- can write to send data to w.\n---\n--- If w is nil, writerDescriptor returns a File that writes to os.DevNull.",
	"execCommand": "--- Command returns the Cmd struct to execute the named program with\n--- the given arguments.\n---\n--- It sets only the Path and Args in the returned structure.\n---\n--- If name contains no path separators, Command uses LookPath to\n--- resolve name to a complete path if possible. Otherwise it uses name\n--- directly as Path.\n---\n--- The returned Cmd's Args field is constructed from the command name\n--- followed by the elements of arg, so arg should not include the\n--- command name itself. For example, Command(\"echo\", \"hello\").\n--- Args[0] is always name, not the possibly resolved Path.\n---\n--- On Windows, processes receive the whole command line as a single string\n--- and do their own parsing. Command combines and quotes Args into a command\n--- line string with an algorithm compatible with applications using\n--- CommandLineToArgvW (which is the most common way). Notable exceptions are\n--- msiexec.exe and cmd.exe (and thus, all batch files), which have a different\n--- unquoting algorithm. In these or other similar cases, you can do the\n--- quoting yourself and provide the full command line in SysProcAttr.CmdLine,\n--- leaving Args empty.",
	"execCommandContext": "--- CommandContext is like Command but includes a context.\n---\n--- The provided context is used to interrupt the process\n--- (by calling cmd.Cancel or os.Process.Kill)\n--- if the context becomes done before the command completes on its own.\n---\n--- CommandContext sets the command's Cancel function to invoke the Kill method\n--- on its Process, and leaves its WaitDelay unset. The caller may change the\n--- cancellation behavior by modifying those fields before starting the command.",
	"execErrorError": "",
	"execErrorUnwrap": "",
	"execExitErrorError": "",
	"execLookPath": "--- LookPath searches for an executable named file in the\n--- directories named by the PATH environment variable.\n--- LookPath also uses PATHEXT environment variable to match\n--- a suitable candidate.\n--- If file contains a slash, it is tried directly and the PATH is not consulted.\n--- Otherwise, on success, the result is an absolute path.\n---\n--- In older versions of Go, LookPath could return a path relative to the current directory.\n--- As of Go 1.19, LookPath will instead return that path along with an error satisfying\n--- errors.Is(err, ErrDot). See the package documentation for more details."
}