{
	"tarFileInfoHeader": "--- FileInfoHeader creates a partially-populated Header from fi.\n--- If fi describes a symlink, FileInfoHeader records link as the link target.\n--- If fi describes a directory, a slash is appended to the name.\n---\n--- Since fs.FileInfo's Name method only returns the base name of\n--- the file it describes, it may be necessary to modify Header.Name\n--- to provide the full path name of the file.",
	"tarFormatString": "",
	"tarFormathas": "",
	"tarFormatmayBe": "",
	"tarFormatmayOnlyBe": "",
	"tarFormatmustNotBe": "",
	"tarHeaderFileInfo": "--- FileInfo returns an fs.FileInfo for the Header.",
	"tarHeaderallowedFormats": "--- allowedFormats determines which formats can be used.\n--- The value returned is the logical OR of multiple possible formats.\n--- If the value is FormatUnknown, then the input Header cannot be encoded\n--- and an error is returned explaining why.\n---\n--- As a by-product of checking the fields, this function returns paxHdrs, which\n--- contain all fields that could not be directly encoded.\n--- A value receiver ensures that this method does not mutate the source Header.",
	"tarNewReader": "--- NewReader creates a new Reader reading from r.",
	"tarNewWriter": "--- NewWriter creates a new Writer writing to w.",
	"tarReaderNext": "--- Next advances to the next entry in the tar archive.\n--- The Header.Size determines how many bytes can be read for the next file.\n--- Any remaining data in the current file is automatically discarded.\n--- At the end of the archive, Next returns the error io.EOF.\n---\n--- If Next encounters a non-local name (as defined by [filepath.IsLocal])\n--- and the GODEBUG environment variable contains `tarinsecurepath=0`,\n--- Next returns the header with an ErrInsecurePath error.\n--- A future version of Go may introduce this behavior by default.\n--- Programs that want to accept non-local names can ignore\n--- the ErrInsecurePath error and use the returned header.",
	"tarReaderRead": "--- Read reads from the current file in the tar archive.\n--- It returns (0, io.EOF) when it reaches the end of that file,\n--- until Next is called to advance to the next file.\n---\n--- If the current file is sparse, then the regions marked as a hole\n--- are read back as NUL-bytes.\n---\n--- Calling Read on special types like TypeLink, TypeSymlink, TypeChar,\n--- TypeBlock, TypeDir, and TypeFifo returns (0, io.EOF) regardless of what\n--- the Header.Size claims.",
	"tarReaderhandleRegularFile": "--- handleRegularFile sets up the current file reader and padding such that it\n--- can only read the following logical data section. It will properly handle\n--- special headers that contain no data section.",
	"tarReaderhandleSparseFile": "--- handleSparseFile checks if the current file is a sparse format of any type\n--- and sets the curr reader appropriately.",
	"tarReadernext": "",
	"tarReaderreadGNUSparsePAXHeaders": "--- readGNUSparsePAXHeaders checks the PAX headers for GNU sparse headers.\n--- If they are found, then this function reads the sparse map and returns it.\n--- This assumes that 0.0 headers have already been converted to 0.1 headers\n--- by the PAX header parsing logic.",
	"tarReaderreadHeader": "--- readHeader reads the next block header and assumes that the underlying reader\n--- is already aligned to a block boundary. It returns the raw block of the\n--- header in case further processing is required.\n---\n--- The err will be set to io.EOF only when one of the following occurs:\n---   - Exactly 0 bytes are read and EOF is hit.\n---   - Exactly 1 block of zeros is read and EOF is hit.\n---   - At least 2 blocks of zeros are read.",
	"tarReaderreadOldGNUSparseMap": "--- readOldGNUSparseMap reads the sparse map from the old GNU sparse format.\n--- The sparse map is stored in the tar header if it's small enough.\n--- If it's larger than four entries, then one or more extension headers are used\n--- to store the rest of the sparse map.\n---\n--- The Header.Size does not reflect the size of any extended headers used.\n--- Thus, this function will read from the raw io.Reader to fetch extra headers.\n--- This method mutates blk in the process.",
	"tarReaderwriteTo": "--- writeTo writes the content of the current file to w.\n--- The bytes written matches the number of remaining bytes in the current file.\n---\n--- If the current file is sparse and w is an io.WriteSeeker,\n--- then writeTo uses Seek to skip past holes defined in Header.SparseHoles,\n--- assuming that skipped regions are filled with NULs.\n--- This always writes the last byte to ensure w is the right size.\n---\n--- TODO(dsnet): Re-export this when adding sparse file support.\n--- See https://golang.org/issue/22735",
	"tarWriterClose": "--- Close closes the tar archive by flushing the padding, and writing the footer.\n--- If the current file (from a prior call to WriteHeader) is not fully written,\n--- then this returns an error.",
	"tarWriterFlush": "--- Flush finishes writing the current file's block padding.\n--- The current file must be fully written before Flush can be called.\n---\n--- This is unnecessary as the next call to WriteHeader or Close\n--- will implicitly flush out the file's padding.",
	"tarWriterWrite": "--- Write writes to the current file in the tar archive.\n--- Write returns the error ErrWriteTooLong if more than\n--- Header.Size bytes are written after WriteHeader.\n---\n--- Calling Write on special types like TypeLink, TypeSymlink, TypeChar,\n--- TypeBlock, TypeDir, and TypeFifo returns (0, ErrWriteTooLong) regardless\n--- of what the Header.Size claims.",
	"tarWriterWriteHeader": "--- WriteHeader writes hdr and prepares to accept the file's contents.\n--- The Header.Size determines how many bytes can be written for the next file.\n--- If the current file is not fully written, then this returns an error.\n--- This implicitly flushes any padding necessary before writing the header.",
	"tarWriterreadFrom": "--- readFrom populates the content of the current file by reading from r.\n--- The bytes read must match the number of remaining bytes in the current file.\n---\n--- If the current file is sparse and r is an io.ReadSeeker,\n--- then readFrom uses Seek to skip past holes defined in Header.SparseHoles,\n--- assuming that skipped regions are all NULs.\n--- This always reads the last byte to ensure r is the right size.\n---\n--- TODO(dsnet): Re-export this when adding sparse file support.\n--- See https://golang.org/issue/22735",
	"tarWritertemplateV7Plus": "--- templateV7Plus fills out the V7 fields of a block using values from hdr.\n--- It also fills out fields (uname, gname, devmajor, devminor) that are\n--- shared in the USTAR, PAX, and GNU formats using the provided formatters.\n---\n--- The block returned is only valid until the next call to\n--- templateV7Plus or writeRawFile.",
	"tarWriterwriteGNUHeader": "",
	"tarWriterwritePAXHeader": "",
	"tarWriterwriteRawFile": "--- writeRawFile writes a minimal file with the given name and flag type.\n--- It uses format to encode the header format and will write data as the body.\n--- It uses default values for all of the other fields (as BSD and GNU tar does).",
	"tarWriterwriteRawHeader": "--- writeRawHeader writes the value of blk, regardless of its value.\n--- It sets up the Writer such that it can accept a file of the given size.\n--- If the flag is a special header-only flag, then the size is treated as zero.",
	"tarWriterwriteUSTARHeader": ""
}