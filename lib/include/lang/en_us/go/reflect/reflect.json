{
	"reflectAppend": "--- Append appends the values x to a slice s and returns the resulting slice.\n--- As in Go, each x's value must be assignable to the slice's element type.",
	"reflectAppendSlice": "--- AppendSlice appends a slice t to a slice s and returns the resulting slice.\n--- The slices s and t must have the same element type.",
	"reflectArenaNew": "--- ArenaNew returns a Value representing a pointer to a new zero value for the\n--- specified type, allocating storage for it in the provided arena. That is,\n--- the returned Value's Type is PointerTo(typ).",
	"reflectArrayOf": "--- ArrayOf returns the array type with the given length and element type.\n--- For example, if t represents int, ArrayOf(5, t) represents [5]int.\n---\n--- If the resulting type would be larger than the available address space,\n--- ArrayOf panics.",
	"reflectChanDirString": "",
	"reflectChanOf": "--- ChanOf returns the channel type with the given direction and element type.\n--- For example, if t represents int, ChanOf(RecvDir, t) represents \u003c-chan int.\n---\n--- The gc runtime imposes a limit of 64 kB on channel element types.\n--- If t's size is equal to or exceeds this limit, ChanOf panics.",
	"reflectCopy": "--- Copy copies the contents of src into dst until either\n--- dst has been filled or src has been exhausted.\n--- It returns the number of elements copied.\n--- Dst and src each must have kind Slice or Array, and\n--- dst and src must have the same element type.\n---\n--- As a special case, src can have kind String if the element type of dst is kind Uint8.",
	"reflectDeepEqual": "--- DeepEqual reports whether x and y are “deeply equal,” defined as follows.\n--- Two values of identical type are deeply equal if one of the following cases applies.\n--- Values of distinct types are never deeply equal.\n---\n--- Array values are deeply equal when their corresponding elements are deeply equal.\n---\n--- Struct values are deeply equal if their corresponding fields,\n--- both exported and unexported, are deeply equal.\n---\n--- Func values are deeply equal if both are nil; otherwise they are not deeply equal.\n---\n--- Interface values are deeply equal if they hold deeply equal concrete values.\n---\n--- Map values are deeply equal when all of the following are true:\n--- they are both nil or both non-nil, they have the same length,\n--- and either they are the same map object or their corresponding keys\n--- (matched using Go equality) map to deeply equal values.\n---\n--- Pointer values are deeply equal if they are equal using Go's == operator\n--- or if they point to deeply equal values.\n---\n--- Slice values are deeply equal when all of the following are true:\n--- they are both nil or both non-nil, they have the same length,\n--- and either they point to the same initial entry of the same underlying array\n--- (that is, \u0026x[0] == \u0026y[0]) or their corresponding elements (up to length) are deeply equal.\n--- Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))\n--- are not deeply equal.\n---\n--- Other values - numbers, bools, strings, and channels - are deeply equal\n--- if they are equal using Go's == operator.\n---\n--- In general DeepEqual is a recursive relaxation of Go's == operator.\n--- However, this idea is impossible to implement without some inconsistency.\n--- Specifically, it is possible for a value to be unequal to itself,\n--- either because it is of func type (uncomparable in general)\n--- or because it is a floating-point NaN value (not equal to itself in floating-point comparison),\n--- or because it is an array, struct, or interface containing\n--- such a value.\n--- On the other hand, pointer values are always equal to themselves,\n--- even if they point at or contain such problematic values,\n--- because they compare equal using Go's == operator, and that\n--- is a sufficient condition to be deeply equal, regardless of content.\n--- DeepEqual has been defined so that the same short-cut applies\n--- to slices and maps: if x and y are the same slice or the same map,\n--- they are deeply equal regardless of content.\n---\n--- As DeepEqual traverses the data values it may find a cycle. The\n--- second and subsequent times that DeepEqual compares two pointer\n--- values that have been compared before, it treats the values as\n--- equal rather than examining the values to which they point.\n--- This ensures that DeepEqual terminates.",
	"reflectFuncOf": "--- FuncOf returns the function type with the given argument and result types.\n--- For example if k represents int and e represents string,\n--- FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.\n---\n--- The variadic argument controls whether the function is variadic. FuncOf\n--- panics if the in[len(in)-1] does not represent a slice and variadic is\n--- true.",
	"reflectIndirect": "--- Indirect returns the value that v points to.\n--- If v is a nil pointer, Indirect returns a zero Value.\n--- If v is not a pointer, Indirect returns v.",
	"reflectKindString": "--- String returns the name of k.",
	"reflectMakeChan": "--- MakeChan creates a new channel with the specified type and buffer size.",
	"reflectMakeFunc": "--- MakeFunc returns a new function of the given Type\n--- that wraps the function fn. When called, that new function\n--- does the following:\n---\n---   - converts its arguments to a slice of Values.\n---   - runs results := fn(args).\n---   - returns the results as a slice of Values, one per formal result.\n---\n--- The implementation fn can assume that the argument Value slice\n--- has the number and type of arguments given by typ.\n--- If typ describes a variadic function, the final Value is itself\n--- a slice representing the variadic arguments, as in the\n--- body of a variadic function. The result Value slice returned by fn\n--- must have the number and type of results given by typ.\n---\n--- The Value.Call method allows the caller to invoke a typed function\n--- in terms of Values; in contrast, MakeFunc allows the caller to implement\n--- a typed function in terms of Values.\n---\n--- The Examples section of the documentation includes an illustration\n--- of how to use MakeFunc to build a swap function for different types.",
	"reflectMakeMap": "--- MakeMap creates a new map with the specified type.",
	"reflectMakeMapWithSize": "--- MakeMapWithSize creates a new map with the specified type\n--- and initial space for approximately n elements.",
	"reflectMakeSlice": "--- MakeSlice creates a new zero-initialized slice value\n--- for the specified slice type, length, and capacity.",
	"reflectMapIterKey": "--- Key returns the key of iter's current map entry.",
	"reflectMapIterNext": "--- Next advances the map iterator and reports whether there is another\n--- entry. It returns false when iter is exhausted; subsequent\n--- calls to Key, Value, or Next will panic.",
	"reflectMapIterReset": "--- Reset modifies iter to iterate over v.\n--- It panics if v's Kind is not Map and v is not the zero Value.\n--- Reset(Value{}) causes iter to not to refer to any map,\n--- which may allow the previously iterated-over map to be garbage collected.",
	"reflectMapIterValue": "--- Value returns the value of iter's current map entry.",
	"reflectMapOf": "--- MapOf returns the map type with the given key and element types.\n--- For example, if k represents int and e represents string,\n--- MapOf(k, e) represents map[int]string.\n---\n--- If the key type is not a valid map key type (that is, if it does\n--- not implement Go's == operator), MapOf panics.",
	"reflectMethodIsExported": "--- IsExported reports whether the method is exported.",
	"reflectNew": "--- New returns a Value representing a pointer to a new zero value\n--- for the specified type. That is, the returned Value's Type is PointerTo(typ).",
	"reflectNewAt": "--- NewAt returns a Value representing a pointer to a value of the\n--- specified type, using p as that pointer.",
	"reflectPointerTo": "--- PointerTo returns the pointer type with element t.\n--- For example, if t represents type Foo, PointerTo(t) represents *Foo.",
	"reflectPtrTo": "--- PtrTo returns the pointer type with element t.\n--- For example, if t represents type Foo, PtrTo(t) represents *Foo.\n---\n--- PtrTo is the old spelling of PointerTo.\n--- The two functions behave identically.",
	"reflectSelect": "--- Select executes a select operation described by the list of cases.\n--- Like the Go select statement, it blocks until at least one of the cases\n--- can proceed, makes a uniform pseudo-random choice,\n--- and then executes that case. It returns the index of the chosen case\n--- and, if that case was a receive operation, the value received and a\n--- boolean indicating whether the value corresponds to a send on the channel\n--- (as opposed to a zero value received because the channel is closed).\n--- Select supports a maximum of 65536 cases.",
	"reflectSliceOf": "--- SliceOf returns the slice type with element type t.\n--- For example, if t represents int, SliceOf(t) represents []int.",
	"reflectStructFieldIsExported": "--- IsExported reports whether the field is exported.",
	"reflectStructOf": "--- StructOf returns the struct type containing fields.\n--- The Offset and Index fields are ignored and computed as they would be\n--- by the compiler.\n---\n--- StructOf currently does not generate wrapper methods for embedded\n--- fields and panics if passed unexported StructFields.\n--- These limitations may be lifted in a future version.",
	"reflectStructTagGet": "--- Get returns the value associated with key in the tag string.\n--- If there is no such key in the tag, Get returns the empty string.\n--- If the tag does not have the conventional format, the value\n--- returned by Get is unspecified. To determine whether a tag is\n--- explicitly set to the empty string, use Lookup.",
	"reflectStructTagLookup": "--- Lookup returns the value associated with key in the tag string.\n--- If the key is present in the tag the value (which may be empty)\n--- is returned. Otherwise the returned value will be the empty string.\n--- The ok return value reports whether the value was explicitly set in\n--- the tag string. If the tag does not have the conventional format,\n--- the value returned by Lookup is unspecified.",
	"reflectSwapper": "--- Swapper returns a function that swaps the elements in the provided\n--- slice.\n---\n--- Swapper panics if the provided interface is not a slice.",
	"reflectTypeOf": "--- TypeOf returns the reflection Type that represents the dynamic type of i.\n--- If i is a nil interface value, TypeOf returns nil.",
	"reflectValueAddr": "--- Addr returns a pointer value representing the address of v.\n--- It panics if CanAddr() returns false.\n--- Addr is typically used to obtain a pointer to a struct field\n--- or slice element in order to call a method that requires a\n--- pointer receiver.",
	"reflectValueBool": "--- Bool returns v's underlying value.\n--- It panics if v's kind is not Bool.",
	"reflectValueBytes": "--- Bytes returns v's underlying value.\n--- It panics if v's underlying value is not a slice of bytes or\n--- an addressable array of bytes.",
	"reflectValueCall": "--- Call calls the function v with the input arguments in.\n--- For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).\n--- Call panics if v's Kind is not Func.\n--- It returns the output results as Values.\n--- As in Go, each input argument must be assignable to the\n--- type of the function's corresponding input parameter.\n--- If v is a variadic function, Call creates the variadic slice parameter\n--- itself, copying in the corresponding values.",
	"reflectValueCallSlice": "--- CallSlice calls the variadic function v with the input arguments in,\n--- assigning the slice in[len(in)-1] to v's final variadic argument.\n--- For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...).\n--- CallSlice panics if v's Kind is not Func or if v is not variadic.\n--- It returns the output results as Values.\n--- As in Go, each input argument must be assignable to the\n--- type of the function's corresponding input parameter.",
	"reflectValueCanAddr": "--- CanAddr reports whether the value's address can be obtained with Addr.\n--- Such values are called addressable. A value is addressable if it is\n--- an element of a slice, an element of an addressable array,\n--- a field of an addressable struct, or the result of dereferencing a pointer.\n--- If CanAddr returns false, calling Addr will panic.",
	"reflectValueCanComplex": "--- CanComplex reports whether Complex can be used without panicking.",
	"reflectValueCanConvert": "--- CanConvert reports whether the value v can be converted to type t.\n--- If v.CanConvert(t) returns true then v.Convert(t) will not panic.",
	"reflectValueCanFloat": "--- CanFloat reports whether Float can be used without panicking.",
	"reflectValueCanInt": "--- CanInt reports whether Int can be used without panicking.",
	"reflectValueCanInterface": "--- CanInterface reports whether Interface can be used without panicking.",
	"reflectValueCanSet": "--- CanSet reports whether the value of v can be changed.\n--- A Value can be changed only if it is addressable and was not\n--- obtained by the use of unexported struct fields.\n--- If CanSet returns false, calling Set or any type-specific\n--- setter (e.g., SetBool, SetInt) will panic.",
	"reflectValueCanUint": "--- CanUint reports whether Uint can be used without panicking.",
	"reflectValueCap": "--- Cap returns v's capacity.\n--- It panics if v's Kind is not Array, Chan, Slice or pointer to Array.",
	"reflectValueClose": "--- Close closes the channel v.\n--- It panics if v's Kind is not Chan.",
	"reflectValueComparable": "--- Comparable reports whether the value v is comparable.\n--- If the type of v is an interface, this checks the dynamic type.\n--- If this reports true then v.Interface() == x will not panic for any x,\n--- nor will v.Equal(u) for any Value u.",
	"reflectValueComplex": "--- Complex returns v's underlying value, as a complex128.\n--- It panics if v's Kind is not Complex64 or Complex128",
	"reflectValueConvert": "--- Convert returns the value v converted to type t.\n--- If the usual Go conversion rules do not allow conversion\n--- of the value v to type t, or if converting v to type t panics, Convert panics.",
	"reflectValueElem": "--- Elem returns the value that the interface v contains\n--- or that the pointer v points to.\n--- It panics if v's Kind is not Interface or Pointer.\n--- It returns the zero Value if v is nil.",
	"reflectValueEqual": "--- Equal reports true if v is equal to u.\n--- For two invalid values, Equal will report true.\n--- For an interface value, Equal will compare the value within the interface.\n--- Otherwise, If the values have different types, Equal will report false.\n--- Otherwise, for arrays and structs Equal will compare each element in order,\n--- and report false if it finds non-equal elements.\n--- During all comparisons, if values of the same type are compared,\n--- and the type is not comparable, Equal will panic.",
	"reflectValueErrorError": "",
	"reflectValueField": "--- Field returns the i'th field of the struct v.\n--- It panics if v's Kind is not Struct or i is out of range.",
	"reflectValueFieldByIndex": "--- FieldByIndex returns the nested field corresponding to index.\n--- It panics if evaluation requires stepping through a nil\n--- pointer or a field that is not a struct.",
	"reflectValueFieldByIndexErr": "--- FieldByIndexErr returns the nested field corresponding to index.\n--- It returns an error if evaluation requires stepping through a nil\n--- pointer, but panics if it must step through a field that\n--- is not a struct.",
	"reflectValueFieldByName": "--- FieldByName returns the struct field with the given name.\n--- It returns the zero Value if no field was found.\n--- It panics if v's Kind is not struct.",
	"reflectValueFieldByNameFunc": "--- FieldByNameFunc returns the struct field with a name\n--- that satisfies the match function.\n--- It panics if v's Kind is not struct.\n--- It returns the zero Value if no field was found.",
	"reflectValueFloat": "--- Float returns v's underlying value, as a float64.\n--- It panics if v's Kind is not Float32 or Float64",
	"reflectValueGrow": "--- Grow increases the slice's capacity, if necessary, to guarantee space for\n--- another n elements. After Grow(n), at least n elements can be appended\n--- to the slice without another allocation.\n---\n--- It panics if v's Kind is not a Slice or if n is negative or too large to\n--- allocate the memory.",
	"reflectValueIndex": "--- Index returns v's i'th element.\n--- It panics if v's Kind is not Array, Slice, or String or i is out of range.",
	"reflectValueInt": "--- Int returns v's underlying value, as an int64.\n--- It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.",
	"reflectValueInterface": "--- Interface returns v's current value as an interface{}.\n--- It is equivalent to:\n---\n---\tvar i interface{} = (v's underlying value)\n---\n--- It panics if the Value was obtained by accessing\n--- unexported struct fields.",
	"reflectValueInterfaceData": "--- InterfaceData returns a pair of unspecified uintptr values.\n--- It panics if v's Kind is not Interface.\n---\n--- In earlier versions of Go, this function returned the interface's\n--- value as a uintptr pair. As of Go 1.4, the implementation of\n--- interface values precludes any defined use of InterfaceData.\n---\n--- Deprecated: The memory representation of interface values is not\n--- compatible with InterfaceData.",
	"reflectValueIsNil": "--- IsNil reports whether its argument v is nil. The argument must be\n--- a chan, func, interface, map, pointer, or slice value; if it is\n--- not, IsNil panics. Note that IsNil is not always equivalent to a\n--- regular comparison with nil in Go. For example, if v was created\n--- by calling ValueOf with an uninitialized interface variable i,\n--- i==nil will be true but v.IsNil will panic as v will be the zero\n--- Value.",
	"reflectValueIsValid": "--- IsValid reports whether v represents a value.\n--- It returns false if v is the zero Value.\n--- If IsValid returns false, all other methods except String panic.\n--- Most functions and methods never return an invalid Value.\n--- If one does, its documentation states the conditions explicitly.",
	"reflectValueIsZero": "--- IsZero reports whether v is the zero value for its type.\n--- It panics if the argument is invalid.",
	"reflectValueKind": "--- Kind returns v's Kind.\n--- If v is the zero Value (IsValid returns false), Kind returns Invalid.",
	"reflectValueLen": "--- Len returns v's length.\n--- It panics if v's Kind is not Array, Chan, Map, Slice, String, or pointer to Array.",
	"reflectValueMapIndex": "--- MapIndex returns the value associated with key in the map v.\n--- It panics if v's Kind is not Map.\n--- It returns the zero Value if key is not found in the map or if v represents a nil map.\n--- As in Go, the key's value must be assignable to the map's key type.",
	"reflectValueMapKeys": "--- MapKeys returns a slice containing all the keys present in the map,\n--- in unspecified order.\n--- It panics if v's Kind is not Map.\n--- It returns an empty slice if v represents a nil map.",
	"reflectValueMapRange": "--- MapRange returns a range iterator for a map.\n--- It panics if v's Kind is not Map.\n---\n--- Call Next to advance the iterator, and Key/Value to access each entry.\n--- Next returns false when the iterator is exhausted.\n--- MapRange follows the same iteration semantics as a range statement.\n---\n--- Example:\n---\n---\titer := reflect.ValueOf(m).MapRange()\n---\tfor iter.Next() {\n---\t\tk := iter.Key()\n---\t\tv := iter.Value()\n---\t\t...\n---\t}",
	"reflectValueMethod": "--- Method returns a function value corresponding to v's i'th method.\n--- The arguments to a Call on the returned function should not include\n--- a receiver; the returned function will always use v as the receiver.\n--- Method panics if i is out of range or if v is a nil interface value.",
	"reflectValueMethodByName": "--- MethodByName returns a function value corresponding to the method\n--- of v with the given name.\n--- The arguments to a Call on the returned function should not include\n--- a receiver; the returned function will always use v as the receiver.\n--- It returns the zero Value if no method was found.",
	"reflectValueNumField": "--- NumField returns the number of fields in the struct v.\n--- It panics if v's Kind is not Struct.",
	"reflectValueNumMethod": "--- NumMethod returns the number of methods in the value's method set.\n---\n--- For a non-interface type, it returns the number of exported methods.\n---\n--- For an interface type, it returns the number of exported and unexported methods.",
	"reflectValueOf": "--- ValueOf returns a new Value initialized to the concrete value\n--- stored in the interface i. ValueOf(nil) returns the zero Value.",
	"reflectValueOverflowComplex": "--- OverflowComplex reports whether the complex128 x cannot be represented by v's type.\n--- It panics if v's Kind is not Complex64 or Complex128.",
	"reflectValueOverflowFloat": "--- OverflowFloat reports whether the float64 x cannot be represented by v's type.\n--- It panics if v's Kind is not Float32 or Float64.",
	"reflectValueOverflowInt": "--- OverflowInt reports whether the int64 x cannot be represented by v's type.\n--- It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.",
	"reflectValueOverflowUint": "--- OverflowUint reports whether the uint64 x cannot be represented by v's type.\n--- It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.",
	"reflectValuePointer": "--- Pointer returns v's value as a uintptr.\n--- It panics if v's Kind is not Chan, Func, Map, Pointer, Slice, or UnsafePointer.\n---\n--- If v's Kind is Func, the returned pointer is an underlying\n--- code pointer, but not necessarily enough to identify a\n--- single function uniquely. The only guarantee is that the\n--- result is zero if and only if v is a nil func Value.\n---\n--- If v's Kind is Slice, the returned pointer is to the first\n--- element of the slice. If the slice is nil the returned value\n--- is 0.  If the slice is empty but non-nil the return value is non-zero.\n---\n--- It's preferred to use uintptr(Value.UnsafePointer()) to get the equivalent result.",
	"reflectValueRecv": "--- Recv receives and returns a value from the channel v.\n--- It panics if v's Kind is not Chan.\n--- The receive blocks until a value is ready.\n--- The boolean value ok is true if the value x corresponds to a send\n--- on the channel, false if it is a zero value received because the channel is closed.",
	"reflectValueSend": "--- Send sends x on the channel v.\n--- It panics if v's kind is not Chan or if x's type is not the same type as v's element type.\n--- As in Go, x's value must be assignable to the channel's element type.",
	"reflectValueSet": "--- Set assigns x to the value v.\n--- It panics if CanSet returns false.\n--- As in Go, x's value must be assignable to v's type and\n--- must not be derived from an unexported field.",
	"reflectValueSetBool": "--- SetBool sets v's underlying value.\n--- It panics if v's Kind is not Bool or if CanSet() is false.",
	"reflectValueSetBytes": "--- SetBytes sets v's underlying value.\n--- It panics if v's underlying value is not a slice of bytes.",
	"reflectValueSetCap": "--- SetCap sets v's capacity to n.\n--- It panics if v's Kind is not Slice or if n is smaller than the length or\n--- greater than the capacity of the slice.",
	"reflectValueSetComplex": "--- SetComplex sets v's underlying value to x.\n--- It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.",
	"reflectValueSetFloat": "--- SetFloat sets v's underlying value to x.\n--- It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.",
	"reflectValueSetInt": "--- SetInt sets v's underlying value to x.\n--- It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.",
	"reflectValueSetIterKey": "--- SetIterKey assigns to v the key of iter's current map entry.\n--- It is equivalent to v.Set(iter.Key()), but it avoids allocating a new Value.\n--- As in Go, the key must be assignable to v's type and\n--- must not be derived from an unexported field.",
	"reflectValueSetIterValue": "--- SetIterValue assigns to v the value of iter's current map entry.\n--- It is equivalent to v.Set(iter.Value()), but it avoids allocating a new Value.\n--- As in Go, the value must be assignable to v's type and\n--- must not be derived from an unexported field.",
	"reflectValueSetLen": "--- SetLen sets v's length to n.\n--- It panics if v's Kind is not Slice or if n is negative or\n--- greater than the capacity of the slice.",
	"reflectValueSetMapIndex": "--- SetMapIndex sets the element associated with key in the map v to elem.\n--- It panics if v's Kind is not Map.\n--- If elem is the zero Value, SetMapIndex deletes the key from the map.\n--- Otherwise if v holds a nil map, SetMapIndex will panic.\n--- As in Go, key's elem must be assignable to the map's key type,\n--- and elem's value must be assignable to the map's elem type.",
	"reflectValueSetPointer": "--- SetPointer sets the [unsafe.Pointer] value v to x.\n--- It panics if v's Kind is not UnsafePointer.",
	"reflectValueSetString": "--- SetString sets v's underlying value to x.\n--- It panics if v's Kind is not String or if CanSet() is false.",
	"reflectValueSetUint": "--- SetUint sets v's underlying value to x.\n--- It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.",
	"reflectValueSetZero": "--- SetZero sets v to be the zero value of v's type.\n--- It panics if CanSet returns false.",
	"reflectValueSlice": "--- Slice returns v[i:j].\n--- It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array,\n--- or if the indexes are out of bounds.",
	"reflectValueSlice3": "--- Slice3 is the 3-index form of the slice operation: it returns v[i:j:k].\n--- It panics if v's Kind is not Array or Slice, or if v is an unaddressable array,\n--- or if the indexes are out of bounds.",
	"reflectValueString": "--- String returns the string v's underlying value, as a string.\n--- String is a special case because of Go's String method convention.\n--- Unlike the other getters, it does not panic if v's Kind is not String.\n--- Instead, it returns a string of the form \"\u003cT value\u003e\" where T is v's type.\n--- The fmt package treats Values specially. It does not call their String\n--- method implicitly but instead prints the concrete values they hold.",
	"reflectValueTryRecv": "--- TryRecv attempts to receive a value from the channel v but will not block.\n--- It panics if v's Kind is not Chan.\n--- If the receive delivers a value, x is the transferred value and ok is true.\n--- If the receive cannot finish without blocking, x is the zero Value and ok is false.\n--- If the channel is closed, x is the zero value for the channel's element type and ok is false.",
	"reflectValueTrySend": "--- TrySend attempts to send x on the channel v but will not block.\n--- It panics if v's Kind is not Chan.\n--- It reports whether the value was sent.\n--- As in Go, x's value must be assignable to the channel's element type.",
	"reflectValueType": "--- Type returns v's type.",
	"reflectValueUint": "--- Uint returns v's underlying value, as a uint64.\n--- It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.",
	"reflectValueUnsafeAddr": "--- UnsafeAddr returns a pointer to v's data, as a uintptr.\n--- It panics if v is not addressable.\n---\n--- It's preferred to use uintptr(Value.Addr().UnsafePointer()) to get the equivalent result.",
	"reflectValueUnsafePointer": "--- UnsafePointer returns v's value as a [unsafe.Pointer].\n--- It panics if v's Kind is not Chan, Func, Map, Pointer, Slice, or UnsafePointer.\n---\n--- If v's Kind is Func, the returned pointer is an underlying\n--- code pointer, but not necessarily enough to identify a\n--- single function uniquely. The only guarantee is that the\n--- result is zero if and only if v is a nil func Value.\n---\n--- If v's Kind is Slice, the returned pointer is to the first\n--- element of the slice. If the slice is nil the returned value\n--- is nil.  If the slice is empty but non-nil the return value is non-nil.",
	"reflectValueassignTo": "--- assignTo returns a value v that can be assigned directly to dst.\n--- It panics if v is not assignable to dst.\n--- For a conversion to an interface type, target, if not nil,\n--- is a suggested scratch space to use.\n--- target must be initialized memory (or nil).",
	"reflectValuebytesSlow": "",
	"reflectValuecall": "",
	"reflectValuecapNonSlice": "",
	"reflectValueextendSlice": "--- extendSlice extends a slice by n elements.\n---\n--- Unlike Value.grow, which modifies the slice in place and\n--- does not change the length of the slice in place,\n--- extendSlice returns a new slice value with the length\n--- incremented by the number of specified elements.",
	"reflectValuegrow": "--- grow is identical to Grow but does not check for assignability.",
	"reflectValuelenNonSlice": "",
	"reflectValuepanicNotBool": "",
	"reflectValuepointer": "--- pointer returns the underlying pointer represented by v.\n--- v.Kind() must be Pointer, Map, Chan, Func, or UnsafePointer\n--- if v.Kind() == Pointer, the base type must not be not-in-heap.",
	"reflectValuerecv": "--- internal recv, possibly non-blocking (nb).\n--- v is known to be a channel.",
	"reflectValuerunes": "--- runes returns v's underlying value.\n--- It panics if v's underlying value is not a slice of runes (int32s).",
	"reflectValuesend": "--- internal send, possibly non-blocking.\n--- v is known to be a channel.",
	"reflectValuesetRunes": "--- setRunes sets v's underlying value.\n--- It panics if v's underlying value is not a slice of runes (int32s).",
	"reflectValuestringNonString": "",
	"reflectValuetypeSlow": "",
	"reflectVisibleFields": "--- VisibleFields returns all the visible fields in t, which must be a\n--- struct type. A field is defined as visible if it's accessible\n--- directly with a FieldByName call. The returned fields include fields\n--- inside anonymous struct members and unexported fields. They follow\n--- the same order found in the struct, with anonymous fields followed\n--- immediately by their promoted fields.\n---\n--- For each element e of the returned slice, the corresponding field\n--- can be retrieved from a value v of type t by calling v.FieldByIndex(e.Index).",
	"reflectZero": "--- Zero returns a Value representing the zero value for the specified type.\n--- The result is different from the zero value of the Value struct,\n--- which represents no value at all.\n--- For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.\n--- The returned value is neither addressable nor settable."
}