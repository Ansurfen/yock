{
	"filepathAbs": "--- Abs returns an absolute representation of path.\n--- If the path is not absolute it will be joined with the current\n--- working directory to turn it into an absolute path. The absolute\n--- path name for a given file is not guaranteed to be unique.\n--- Abs calls Clean on the result.",
	"filepathBase": "--- Base returns the last element of path.\n--- Trailing path separators are removed before extracting the last element.\n--- If the path is empty, Base returns \".\".\n--- If the path consists entirely of separators, Base returns a single separator.",
	"filepathClean": "--- Clean returns the shortest path name equivalent to path\n--- by purely lexical processing. It applies the following rules\n--- iteratively until no further processing can be done:\n---\n---  1. Replace multiple Separator elements with a single one.\n---  2. Eliminate each . path name element (the current directory).\n---  3. Eliminate each inner .. path name element (the parent directory)\n---     along with the non-.. element that precedes it.\n---  4. Eliminate .. elements that begin a rooted path:\n---     that is, replace \"/..\" by \"/\" at the beginning of a path,\n---     assuming Separator is '/'.\n---\n--- The returned path ends in a slash only if it represents a root directory,\n--- such as \"/\" on Unix or `C:\\` on Windows.\n---\n--- Finally, any occurrences of slash are replaced by Separator.\n---\n--- If the result of this process is an empty string, Clean\n--- returns the string \".\".\n---\n--- See also Rob Pike, “Lexical File Names in Plan 9 or\n--- Getting Dot-Dot Right,”\n--- https://9p.io/sys/doc/lexnames.html",
	"filepathDir": "--- Dir returns all but the last element of path, typically the path's directory.\n--- After dropping the final element, Dir calls Clean on the path and trailing\n--- slashes are removed.\n--- If the path is empty, Dir returns \".\".\n--- If the path consists entirely of separators, Dir returns a single separator.\n--- The returned path does not end in a separator unless it is the root directory.",
	"filepathEvalSymlinks": "--- EvalSymlinks returns the path name after the evaluation of any symbolic\n--- links.\n--- If path is relative the result will be relative to the current directory,\n--- unless one of the components is an absolute symbolic link.\n--- EvalSymlinks calls Clean on the result.",
	"filepathExt": "--- Ext returns the file name extension used by path.\n--- The extension is the suffix beginning at the final dot\n--- in the final element of path; it is empty if there is\n--- no dot.",
	"filepathFromSlash": "--- FromSlash returns the result of replacing each slash ('/') character\n--- in path with a separator character. Multiple slashes are replaced\n--- by multiple separators.",
	"filepathGlob": "--- Glob returns the names of all files matching pattern or nil\n--- if there is no matching file. The syntax of patterns is the same\n--- as in Match. The pattern may describe hierarchical names such as\n--- /usr/*/bin/ed (assuming the Separator is '/').\n---\n--- Glob ignores file system errors such as I/O errors reading directories.\n--- The only possible returned error is ErrBadPattern, when pattern\n--- is malformed.",
	"filepathHasPrefix": "--- HasPrefix exists for historical compatibility and should not be used.\n---\n--- Deprecated: HasPrefix does not respect path boundaries and\n--- does not ignore case when required.",
	"filepathIsAbs": "--- IsAbs reports whether the path is absolute.",
	"filepathIsLocal": "--- IsLocal reports whether path, using lexical analysis only, has all of these properties:\n---\n---   - is within the subtree rooted at the directory in which path is evaluated\n---   - is not an absolute path\n---   - is not empty\n---   - on Windows, is not a reserved name such as \"NUL\"\n---\n--- If IsLocal(path) returns true, then\n--- Join(base, path) will always produce a path contained within base and\n--- Clean(path) will always produce an unrooted path with no \"..\" path elements.\n---\n--- IsLocal is a purely lexical operation.\n--- In particular, it does not account for the effect of any symbolic links\n--- that may exist in the filesystem.",
	"filepathJoin": "--- Join joins any number of path elements into a single path,\n--- separating them with an OS specific Separator. Empty elements\n--- are ignored. The result is Cleaned. However, if the argument\n--- list is empty or all its elements are empty, Join returns\n--- an empty string.\n--- On Windows, the result will only be a UNC path if the first\n--- non-empty element is a UNC path.",
	"filepathMatch": "--- Match reports whether name matches the shell file name pattern.\n--- The pattern syntax is:\n---\n---\tpattern:\n---\t\t{ term }\n---\tterm:\n---\t\t'*'         matches any sequence of non-Separator characters\n---\t\t'?'         matches any single non-Separator character\n---\t\t'[' [ '^' ] { character-range } ']'\n---\t\t            character class (must be non-empty)\n---\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n---\t\t'\\\\' c      matches character c\n---\n---\tcharacter-range:\n---\t\tc           matches character c (c != '\\\\', '-', ']')\n---\t\t'\\\\' c      matches character c\n---\t\tlo '-' hi   matches character c for lo \u003c= c \u003c= hi\n---\n--- Match requires pattern to match all of name, not just a substring.\n--- The only possible returned error is ErrBadPattern, when pattern\n--- is malformed.\n---\n--- On Windows, escaping is disabled. Instead, '\\\\' is treated as\n--- path separator.",
	"filepathRel": "--- Rel returns a relative path that is lexically equivalent to targpath when\n--- joined to basepath with an intervening separator. That is,\n--- Join(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.\n--- On success, the returned path will always be relative to basepath,\n--- even if basepath and targpath share no elements.\n--- An error is returned if targpath can't be made relative to basepath or if\n--- knowing the current working directory would be necessary to compute it.\n--- Rel calls Clean on the result.",
	"filepathSplit": "--- Split splits path immediately following the final Separator,\n--- separating it into a directory and file name component.\n--- If there is no Separator in path, Split returns an empty dir\n--- and file set to path.\n--- The returned values have the property that path = dir+file.",
	"filepathSplitList": "--- SplitList splits a list of paths joined by the OS-specific ListSeparator,\n--- usually found in PATH or GOPATH environment variables.\n--- Unlike strings.Split, SplitList returns an empty slice when passed an empty\n--- string.",
	"filepathToSlash": "--- ToSlash returns the result of replacing each separator character\n--- in path with a slash ('/') character. Multiple separators are\n--- replaced by multiple slashes.",
	"filepathVolumeName": "--- VolumeName returns leading volume name.\n--- Given \"C:\\foo\\bar\" it returns \"C:\" on Windows.\n--- Given \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\".\n--- On other platforms it returns \"\".",
	"filepathWalk": "--- Walk walks the file tree rooted at root, calling fn for each file or\n--- directory in the tree, including root.\n---\n--- All errors that arise visiting files and directories are filtered by fn:\n--- see the WalkFunc documentation for details.\n---\n--- The files are walked in lexical order, which makes the output deterministic\n--- but requires Walk to read an entire directory into memory before proceeding\n--- to walk that directory.\n---\n--- Walk does not follow symbolic links.\n---\n--- Walk is less efficient than WalkDir, introduced in Go 1.16,\n--- which avoids calling os.Lstat on every visited file or directory.",
	"filepathWalkDir": "--- WalkDir walks the file tree rooted at root, calling fn for each file or\n--- directory in the tree, including root.\n---\n--- All errors that arise visiting files and directories are filtered by fn:\n--- see the fs.WalkDirFunc documentation for details.\n---\n--- The files are walked in lexical order, which makes the output deterministic\n--- but requires WalkDir to read an entire directory into memory before proceeding\n--- to walk that directory.\n---\n--- WalkDir does not follow symbolic links.\n---\n--- WalkDir calls fn with paths that use the separator character appropriate\n--- for the operating system. This is unlike [io/fs.WalkDir], which always\n--- uses slash separated paths."
}