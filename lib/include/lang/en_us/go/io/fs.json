{
	"fsFileInfoToDirEntry": "--- FileInfoToDirEntry returns a DirEntry that returns information from info.\n--- If info is nil, FileInfoToDirEntry returns nil.",
	"fsFileModeIsDir": "--- IsDir reports whether m describes a directory.\n--- That is, it tests for the ModeDir bit being set in m.",
	"fsFileModeIsRegular": "--- IsRegular reports whether m describes a regular file.\n--- That is, it tests that no mode type bits are set.",
	"fsFileModePerm": "--- Perm returns the Unix permission bits in m (m \u0026 ModePerm).",
	"fsFileModeString": "",
	"fsFileModeType": "--- Type returns type bits in m (m \u0026 ModeType).",
	"fsGlob": "--- Glob returns the names of all files matching pattern or nil\n--- if there is no matching file. The syntax of patterns is the same\n--- as in path.Match. The pattern may describe hierarchical names such as\n--- usr/*/bin/ed.\n---\n--- Glob ignores file system errors such as I/O errors reading directories.\n--- The only possible returned error is path.ErrBadPattern, reporting that\n--- the pattern is malformed.\n---\n--- If fs implements GlobFS, Glob calls fs.Glob.\n--- Otherwise, Glob uses ReadDir to traverse the directory tree\n--- and look for matches for the pattern.",
	"fsPathErrorError": "",
	"fsPathErrorTimeout": "--- Timeout reports whether this error represents a timeout.",
	"fsPathErrorUnwrap": "",
	"fsReadDir": "--- ReadDir reads the named directory\n--- and returns a list of directory entries sorted by filename.\n---\n--- If fs implements ReadDirFS, ReadDir calls fs.ReadDir.\n--- Otherwise ReadDir calls fs.Open and uses ReadDir and Close\n--- on the returned file.",
	"fsReadFile": "--- ReadFile reads the named file from the file system fs and returns its contents.\n--- A successful call returns a nil error, not io.EOF.\n--- (Because ReadFile reads the whole file, the expected EOF\n--- from the final Read is not treated as an error to be reported.)\n---\n--- If fs implements ReadFileFS, ReadFile calls fs.ReadFile.\n--- Otherwise ReadFile calls fs.Open and uses Read and Close\n--- on the returned file.",
	"fsStat": "--- Stat returns a FileInfo describing the named file from the file system.\n---\n--- If fs implements StatFS, Stat calls fs.Stat.\n--- Otherwise, Stat opens the file to stat it.",
	"fsSub": "--- Sub returns an FS corresponding to the subtree rooted at fsys's dir.\n---\n--- If dir is \".\", Sub returns fsys unchanged.\n--- Otherwise, if fs implements SubFS, Sub returns fsys.Sub(dir).\n--- Otherwise, Sub returns a new FS implementation sub that,\n--- in effect, implements sub.Open(name) as fsys.Open(path.Join(dir, name)).\n--- The implementation also translates calls to ReadDir, ReadFile, and Glob appropriately.\n---\n--- Note that Sub(os.DirFS(\"/\"), \"prefix\") is equivalent to os.DirFS(\"/prefix\")\n--- and that neither of them guarantees to avoid operating system\n--- accesses outside \"/prefix\", because the implementation of os.DirFS\n--- does not check for symbolic links inside \"/prefix\" that point to\n--- other directories. That is, os.DirFS is not a general substitute for a\n--- chroot-style security mechanism, and Sub does not change that fact.",
	"fsValidPath": "--- ValidPath reports whether the given path name\n--- is valid for use in a call to Open.\n---\n--- Path names passed to open are UTF-8-encoded,\n--- unrooted, slash-separated sequences of path elements, like “x/y/z”.\n--- Path names must not contain an element that is “.” or “..” or the empty string,\n--- except for the special case that the root directory is named “.”.\n--- Paths must not start or end with a slash: “/x” and “x/” are invalid.\n---\n--- Note that paths are slash-separated on all systems, even Windows.\n--- Paths containing other characters such as backslash and colon\n--- are accepted as valid, but those characters must never be\n--- interpreted by an FS implementation as path element separators.",
	"fsWalkDir": "--- WalkDir walks the file tree rooted at root, calling fn for each file or\n--- directory in the tree, including root.\n---\n--- All errors that arise visiting files and directories are filtered by fn:\n--- see the fs.WalkDirFunc documentation for details.\n---\n--- The files are walked in lexical order, which makes the output deterministic\n--- but requires WalkDir to read an entire directory into memory before proceeding\n--- to walk that directory.\n---\n--- WalkDir does not follow symbolic links found in directories,\n--- but if root itself is a symbolic link, its target will be walked."
}