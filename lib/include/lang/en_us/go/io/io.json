{
	"ioCopy": "--- Copy copies from src to dst until either EOF is reached\n--- on src or an error occurs. It returns the number of bytes\n--- copied and the first error encountered while copying, if any.\n---\n--- A successful Copy returns err == nil, not err == EOF.\n--- Because Copy is defined to read from src until EOF, it does\n--- not treat an EOF from Read as an error to be reported.\n---\n--- If src implements the WriterTo interface,\n--- the copy is implemented by calling src.WriteTo(dst).\n--- Otherwise, if dst implements the ReaderFrom interface,\n--- the copy is implemented by calling dst.ReadFrom(src).",
	"ioCopyBuffer": "--- CopyBuffer is identical to Copy except that it stages through the\n--- provided buffer (if one is required) rather than allocating a\n--- temporary one. If buf is nil, one is allocated; otherwise if it has\n--- zero length, CopyBuffer panics.\n---\n--- If either src implements WriterTo or dst implements ReaderFrom,\n--- buf will not be used to perform the copy.",
	"ioCopyN": "--- CopyN copies n bytes (or until an error) from src to dst.\n--- It returns the number of bytes copied and the earliest\n--- error encountered while copying.\n--- On return, written == n if and only if err == nil.\n---\n--- If dst implements the ReaderFrom interface,\n--- the copy is implemented using it.",
	"ioLimitReader": "--- LimitReader returns a Reader that reads from r\n--- but stops with EOF after n bytes.\n--- The underlying implementation is a *LimitedReader.",
	"ioLimitedReaderRead": "",
	"ioMultiReader": "--- MultiReader returns a Reader that's the logical concatenation of\n--- the provided input readers. They're read sequentially. Once all\n--- inputs have returned EOF, Read will return EOF.  If any of the readers\n--- return a non-nil, non-EOF error, Read will return that error.",
	"ioMultiWriter": "--- MultiWriter creates a writer that duplicates its writes to all the\n--- provided writers, similar to the Unix tee(1) command.\n---\n--- Each write is written to each listed writer, one at a time.\n--- If a listed writer returns an error, that overall write operation\n--- stops and returns the error; it does not continue down the list.",
	"ioNewOffsetWriter": "--- NewOffsetWriter returns an OffsetWriter that writes to w\n--- starting at offset off.",
	"ioNewSectionReader": "--- NewSectionReader returns a SectionReader that reads from r\n--- starting at offset off and stops with EOF after n bytes.",
	"ioNopCloser": "--- NopCloser returns a ReadCloser with a no-op Close method wrapping\n--- the provided Reader r.\n--- If r implements WriterTo, the returned ReadCloser will implement WriterTo\n--- by forwarding calls to r.",
	"ioOffsetWriterSeek": "",
	"ioOffsetWriterWrite": "",
	"ioOffsetWriterWriteAt": "",
	"ioPipe": "--- Pipe creates a synchronous in-memory pipe.\n--- It can be used to connect code expecting an io.Reader\n--- with code expecting an io.Writer.\n---\n--- Reads and Writes on the pipe are matched one to one\n--- except when multiple Reads are needed to consume a single Write.\n--- That is, each Write to the PipeWriter blocks until it has satisfied\n--- one or more Reads from the PipeReader that fully consume\n--- the written data.\n--- The data is copied directly from the Write to the corresponding\n--- Read (or Reads); there is no internal buffering.\n---\n--- It is safe to call Read and Write in parallel with each other or with Close.\n--- Parallel calls to Read and parallel calls to Write are also safe:\n--- the individual calls will be gated sequentially.",
	"ioPipeReaderClose": "--- Close closes the reader; subsequent writes to the\n--- write half of the pipe will return the error ErrClosedPipe.",
	"ioPipeReaderCloseWithError": "--- CloseWithError closes the reader; subsequent writes\n--- to the write half of the pipe will return the error err.\n---\n--- CloseWithError never overwrites the previous error if it exists\n--- and always returns nil.",
	"ioPipeReaderRead": "--- Read implements the standard Read interface:\n--- it reads data from the pipe, blocking until a writer\n--- arrives or the write end is closed.\n--- If the write end is closed with an error, that error is\n--- returned as err; otherwise err is EOF.",
	"ioPipeWriterClose": "--- Close closes the writer; subsequent reads from the\n--- read half of the pipe will return no bytes and EOF.",
	"ioPipeWriterCloseWithError": "--- CloseWithError closes the writer; subsequent reads from the\n--- read half of the pipe will return no bytes and the error err,\n--- or EOF if err is nil.\n---\n--- CloseWithError never overwrites the previous error if it exists\n--- and always returns nil.",
	"ioPipeWriterWrite": "--- Write implements the standard Write interface:\n--- it writes data to the pipe, blocking until one or more readers\n--- have consumed all the data or the read end is closed.\n--- If the read end is closed with an error, that err is\n--- returned as err; otherwise err is ErrClosedPipe.",
	"ioReadAll": "--- ReadAll reads from r until an error or EOF and returns the data it read.\n--- A successful call returns err == nil, not err == EOF. Because ReadAll is\n--- defined to read from src until EOF, it does not treat an EOF from Read\n--- as an error to be reported.",
	"ioReadAtLeast": "--- ReadAtLeast reads from r into buf until it has read at least min bytes.\n--- It returns the number of bytes copied and an error if fewer bytes were read.\n--- The error is EOF only if no bytes were read.\n--- If an EOF happens after reading fewer than min bytes,\n--- ReadAtLeast returns ErrUnexpectedEOF.\n--- If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\n--- On return, n \u003e= min if and only if err == nil.\n--- If r returns an error having read at least min bytes, the error is dropped.",
	"ioReadFull": "--- ReadFull reads exactly len(buf) bytes from r into buf.\n--- It returns the number of bytes copied and an error if fewer bytes were read.\n--- The error is EOF only if no bytes were read.\n--- If an EOF happens after reading some but not all the bytes,\n--- ReadFull returns ErrUnexpectedEOF.\n--- On return, n == len(buf) if and only if err == nil.\n--- If r returns an error having read at least len(buf) bytes, the error is dropped.",
	"ioSectionReaderRead": "",
	"ioSectionReaderReadAt": "",
	"ioSectionReaderSeek": "",
	"ioSectionReaderSize": "--- Size returns the size of the section in bytes.",
	"ioTeeReader": "--- TeeReader returns a Reader that writes to w what it reads from r.\n--- All reads from r performed through it are matched with\n--- corresponding writes to w. There is no internal buffering -\n--- the write must complete before the read completes.\n--- Any error encountered while writing is reported as a read error.",
	"ioWriteString": "--- WriteString writes the contents of the string s to w, which accepts a slice of bytes.\n--- If w implements StringWriter, its WriteString method is invoked directly.\n--- Otherwise, w.Write is called exactly once."
}