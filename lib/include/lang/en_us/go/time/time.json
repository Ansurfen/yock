{
	"timeAfter": "--- After waits for the duration to elapse and then sends the current time\n--- on the returned channel.\n--- It is equivalent to NewTimer(d).C.\n--- The underlying Timer is not recovered by the garbage collector\n--- until the timer fires. If efficiency is a concern, use NewTimer\n--- instead and call Timer.Stop if the timer is no longer needed.",
	"timeAfterFunc": "--- AfterFunc waits for the duration to elapse and then calls f\n--- in its own goroutine. It returns a Timer that can\n--- be used to cancel the call using its Stop method.",
	"timeDate": "--- Date returns the Time corresponding to\n---\n---\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\n---\n--- in the appropriate zone for that time in the given location.\n---\n--- The month, day, hour, min, sec, and nsec values may be outside\n--- their usual ranges and will be normalized during the conversion.\n--- For example, October 32 converts to November 1.\n---\n--- A daylight savings time transition skips or repeats times.\n--- For example, in the United States, March 13, 2011 2:15am never occurred,\n--- while November 6, 2011 1:15am occurred twice. In such cases, the\n--- choice of time zone, and therefore the time, is not well-defined.\n--- Date returns a time that is correct in one of the two zones involved\n--- in the transition, but it does not guarantee which.\n---\n--- Date panics if loc is nil.",
	"timeDurationAbs": "--- Abs returns the absolute value of d.\n--- As a special case, math.MinInt64 is converted to math.MaxInt64.",
	"timeDurationHours": "--- Hours returns the duration as a floating point number of hours.",
	"timeDurationMicroseconds": "--- Microseconds returns the duration as an integer microsecond count.",
	"timeDurationMilliseconds": "--- Milliseconds returns the duration as an integer millisecond count.",
	"timeDurationMinutes": "--- Minutes returns the duration as a floating point number of minutes.",
	"timeDurationNanoseconds": "--- Nanoseconds returns the duration as an integer nanosecond count.",
	"timeDurationRound": "--- Round returns the result of rounding d to the nearest multiple of m.\n--- The rounding behavior for halfway values is to round away from zero.\n--- If the result exceeds the maximum (or minimum)\n--- value that can be stored in a Duration,\n--- Round returns the maximum (or minimum) duration.\n--- If m \u003c= 0, Round returns d unchanged.",
	"timeDurationSeconds": "--- Seconds returns the duration as a floating point number of seconds.",
	"timeDurationString": "--- String returns a string representing the duration in the form \"72h3m0.5s\".\n--- Leading zero units are omitted. As a special case, durations less than one\n--- second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure\n--- that the leading digit is non-zero. The zero duration formats as 0s.",
	"timeDurationTruncate": "--- Truncate returns the result of rounding d toward zero to a multiple of m.\n--- If m \u003c= 0, Truncate returns d unchanged.",
	"timeFixedZone": "--- FixedZone returns a Location that always uses\n--- the given zone name and offset (seconds east of UTC).",
	"timeLoadLocation": "--- LoadLocation returns the Location with the given name.\n---\n--- If the name is \"\" or \"UTC\", LoadLocation returns UTC.\n--- If the name is \"Local\", LoadLocation returns Local.\n---\n--- Otherwise, the name is taken to be a location name corresponding to a file\n--- in the IANA Time Zone database, such as \"America/New_York\".\n---\n--- LoadLocation looks for the IANA Time Zone database in the following\n--- locations in order:\n---\n---   - the directory or uncompressed zip file named by the ZONEINFO environment variable\n---   - on a Unix system, the system standard installation location\n---   - $GOROOT/lib/time/zoneinfo.zip\n---   - the time/tzdata package, if it was imported",
	"timeLoadLocationFromTZData": "--- LoadLocationFromTZData returns a Location with the given name\n--- initialized from the IANA Time Zone database-formatted data.\n--- The data should be in the format of a standard IANA time zone file\n--- (for example, the content of /etc/localtime on Unix systems).",
	"timeLocationString": "--- String returns a descriptive name for the time zone information,\n--- corresponding to the name argument to LoadLocation or FixedZone.",
	"timeLocationfirstZoneUsed": "--- firstZoneUsed reports whether the first zone is used by some\n--- transition.",
	"timeLocationget": "",
	"timeLocationlookup": "--- lookup returns information about the time zone in use at an\n--- instant in time expressed as seconds since January 1, 1970 00:00:00 UTC.\n---\n--- The returned information gives the name of the zone (such as \"CET\"),\n--- the start and end times bracketing sec when that zone is in effect,\n--- the offset in seconds east of UTC (such as -5*60*60), and whether\n--- the daylight savings is being observed at that time.",
	"timeLocationlookupFirstZone": "--- lookupFirstZone returns the index of the time zone to use for times\n--- before the first transition time, or when there are no transition\n--- times.\n---\n--- The reference implementation in localtime.c from\n--- https://www.iana.org/time-zones/repository/releases/tzcode2013g.tar.gz\n--- implements the following algorithm for these cases:\n---  1. If the first zone is unused by the transitions, use it.\n---  2. Otherwise, if there are transition times, and the first\n---     transition is to a zone in daylight time, find the first\n---     non-daylight-time zone before and closest to the first transition\n---     zone.\n---  3. Otherwise, use the first zone that is not daylight time, if\n---     there is one.\n---  4. Otherwise, use the first zone.",
	"timeLocationlookupName": "--- lookupName returns information about the time zone with\n--- the given name (such as \"EST\") at the given pseudo-Unix time\n--- (what the given time of day would be in UTC).",
	"timeMonthString": "--- String returns the English name of the month (\"January\", \"February\", ...).",
	"timeNewTicker": "--- NewTicker returns a new Ticker containing a channel that will send\n--- the current time on the channel after each tick. The period of the\n--- ticks is specified by the duration argument. The ticker will adjust\n--- the time interval or drop ticks to make up for slow receivers.\n--- The duration d must be greater than zero; if not, NewTicker will\n--- panic. Stop the ticker to release associated resources.",
	"timeNewTimer": "--- NewTimer creates a new Timer that will send\n--- the current time on its channel after at least duration d.",
	"timeNow": "--- Now returns the current local time.",
	"timeParse": "--- Parse parses a formatted string and returns the time value it represents.\n--- See the documentation for the constant called Layout to see how to\n--- represent the format. The second argument must be parseable using\n--- the format string (layout) provided as the first argument.\n---\n--- The example for Time.Format demonstrates the working of the layout string\n--- in detail and is a good reference.\n---\n--- When parsing (only), the input may contain a fractional second\n--- field immediately after the seconds field, even if the layout does not\n--- signify its presence. In that case either a comma or a decimal point\n--- followed by a maximal series of digits is parsed as a fractional second.\n--- Fractional seconds are truncated to nanosecond precision.\n---\n--- Elements omitted from the layout are assumed to be zero or, when\n--- zero is impossible, one, so parsing \"3:04pm\" returns the time\n--- corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is\n--- 0, this time is before the zero Time).\n--- Years must be in the range 0000..9999. The day of the week is checked\n--- for syntax but it is otherwise ignored.\n---\n--- For layouts specifying the two-digit year 06, a value NN \u003e= 69 will be treated\n--- as 19NN and a value NN \u003c 69 will be treated as 20NN.\n---\n--- The remainder of this comment describes the handling of time zones.\n---\n--- In the absence of a time zone indicator, Parse returns a time in UTC.\n---\n--- When parsing a time with a zone offset like -0700, if the offset corresponds\n--- to a time zone used by the current location (Local), then Parse uses that\n--- location and zone in the returned time. Otherwise it records the time as\n--- being in a fabricated location with time fixed at the given zone offset.\n---\n--- When parsing a time with a zone abbreviation like MST, if the zone abbreviation\n--- has a defined offset in the current location, then that offset is used.\n--- The zone abbreviation \"UTC\" is recognized as UTC regardless of location.\n--- If the zone abbreviation is unknown, Parse records the time as being\n--- in a fabricated location with the given zone abbreviation and a zero offset.\n--- This choice means that such a time can be parsed and reformatted with the\n--- same layout losslessly, but the exact instant used in the representation will\n--- differ by the actual zone offset. To avoid such problems, prefer time layouts\n--- that use a numeric zone offset, or use ParseInLocation.",
	"timeParseDuration": "--- ParseDuration parses a duration string.\n--- A duration string is a possibly signed sequence of\n--- decimal numbers, each with optional fraction and a unit suffix,\n--- such as \"300ms\", \"-1.5h\" or \"2h45m\".\n--- Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".",
	"timeParseErrorError": "--- Error returns the string representation of a ParseError.",
	"timeParseInLocation": "--- ParseInLocation is like Parse but differs in two important ways.\n--- First, in the absence of time zone information, Parse interprets a time as UTC;\n--- ParseInLocation interprets the time as in the given location.\n--- Second, when given a zone offset or abbreviation, Parse tries to match it\n--- against the Local location; ParseInLocation uses the given location.",
	"timeSince": "--- Since returns the time elapsed since t.\n--- It is shorthand for time.Now().Sub(t).",
	"timeSleep": "--- Sleep pauses the current goroutine for at least the duration d.\n--- A negative or zero duration causes Sleep to return immediately.",
	"timeTick": "--- Tick is a convenience wrapper for NewTicker providing access to the ticking\n--- channel only. While Tick is useful for clients that have no need to shut down\n--- the Ticker, be aware that without a way to shut it down the underlying\n--- Ticker cannot be recovered by the garbage collector; it \"leaks\".\n--- Unlike NewTicker, Tick will return nil if d \u003c= 0.",
	"timeTickerReset": "--- Reset stops a ticker and resets its period to the specified duration.\n--- The next tick will arrive after the new period elapses. The duration d\n--- must be greater than zero; if not, Reset will panic.",
	"timeTickerStop": "--- Stop turns off a ticker. After Stop, no more ticks will be sent.\n--- Stop does not close the channel, to prevent a concurrent goroutine\n--- reading from the channel from seeing an erroneous \"tick\".",
	"timeTimeAdd": "--- Add returns the time t+d.",
	"timeTimeAddDate": "--- AddDate returns the time corresponding to adding the\n--- given number of years, months, and days to t.\n--- For example, AddDate(-1, 2, 3) applied to January 1, 2011\n--- returns March 4, 2010.\n---\n--- AddDate normalizes its result in the same way that Date does,\n--- so, for example, adding one month to October 31 yields\n--- December 1, the normalized form for November 31.",
	"timeTimeAfter": "--- After reports whether the time instant t is after u.",
	"timeTimeBefore": "--- Before reports whether the time instant t is before u.",
	"timeTimeClock": "--- Clock returns the hour, minute, and second within the day specified by t.",
	"timeTimeCompare": "--- Compare compares the time instant t with u. If t is before u, it returns -1;\n--- if t is after u, it returns +1; if they're the same, it returns 0.",
	"timeTimeDate": "--- Date returns the year, month, and day in which t occurs.",
	"timeTimeDay": "--- Day returns the day of the month specified by t.",
	"timeTimeEqual": "--- Equal reports whether t and u represent the same time instant.\n--- Two times can be equal even if they are in different locations.\n--- For example, 6:00 +0200 and 4:00 UTC are Equal.\n--- See the documentation on the Time type for the pitfalls of using == with\n--- Time values; most code should use Equal instead.",
	"timeTimeGobDecode": "--- GobDecode implements the gob.GobDecoder interface.",
	"timeTimeGobEncode": "--- GobEncode implements the gob.GobEncoder interface.",
	"timeTimeHour": "--- Hour returns the hour within the day specified by t, in the range [0, 23].",
	"timeTimeISOWeek": "--- ISOWeek returns the ISO 8601 year and week number in which t occurs.\n--- Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to\n--- week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1\n--- of year n+1.",
	"timeTimeIn": "--- In returns a copy of t representing the same time instant, but\n--- with the copy's location information set to loc for display\n--- purposes.\n---\n--- In panics if loc is nil.",
	"timeTimeIsDST": "--- IsDST reports whether the time in the configured location is in Daylight Savings Time.",
	"timeTimeIsZero": "--- IsZero reports whether t represents the zero time instant,\n--- January 1, year 1, 00:00:00 UTC.",
	"timeTimeLocal": "--- Local returns t with the location set to local time.",
	"timeTimeLocation": "--- Location returns the time zone information associated with t.",
	"timeTimeMarshalBinary": "--- MarshalBinary implements the encoding.BinaryMarshaler interface.",
	"timeTimeMarshalJSON": "--- MarshalJSON implements the json.Marshaler interface.\n--- The time is a quoted string in the RFC 3339 format with sub-second precision.\n--- If the timestamp cannot be represented as valid RFC 3339\n--- (e.g., the year is out of range), then an error is reported.",
	"timeTimeMarshalText": "--- MarshalText implements the encoding.TextMarshaler interface.\n--- The time is formatted in RFC 3339 format with sub-second precision.\n--- If the timestamp cannot be represented as valid RFC 3339\n--- (e.g., the year is out of range), then an error is reported.",
	"timeTimeMinute": "--- Minute returns the minute offset within the hour specified by t, in the range [0, 59].",
	"timeTimeMonth": "--- Month returns the month of the year specified by t.",
	"timeTimeNanosecond": "--- Nanosecond returns the nanosecond offset within the second specified by t,\n--- in the range [0, 999999999].",
	"timeTimeRound": "--- Round returns the result of rounding t to the nearest multiple of d (since the zero time).\n--- The rounding behavior for halfway values is to round up.\n--- If d \u003c= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.\n---\n--- Round operates on the time as an absolute duration since the\n--- zero time; it does not operate on the presentation form of the\n--- time. Thus, Round(Hour) may return a time with a non-zero\n--- minute, depending on the time's Location.",
	"timeTimeSecond": "--- Second returns the second offset within the minute specified by t, in the range [0, 59].",
	"timeTimeSub": "--- Sub returns the duration t-u. If the result exceeds the maximum (or minimum)\n--- value that can be stored in a Duration, the maximum (or minimum) duration\n--- will be returned.\n--- To compute t-d for a duration d, use t.Add(-d).",
	"timeTimeTruncate": "--- Truncate returns the result of rounding t down to a multiple of d (since the zero time).\n--- If d \u003c= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.\n---\n--- Truncate operates on the time as an absolute duration since the\n--- zero time; it does not operate on the presentation form of the\n--- time. Thus, Truncate(Hour) may return a time with a non-zero\n--- minute, depending on the time's Location.",
	"timeTimeUTC": "--- UTC returns t with the location set to UTC.",
	"timeTimeUnix": "--- Unix returns t as a Unix time, the number of seconds elapsed\n--- since January 1, 1970 UTC. The result does not depend on the\n--- location associated with t.\n--- Unix-like operating systems often record time as a 32-bit\n--- count of seconds, but since the method here returns a 64-bit\n--- value it is valid for billions of years into the past or future.",
	"timeTimeUnixMicro": "--- UnixMicro returns t as a Unix time, the number of microseconds elapsed since\n--- January 1, 1970 UTC. The result is undefined if the Unix time in\n--- microseconds cannot be represented by an int64 (a date before year -290307 or\n--- after year 294246). The result does not depend on the location associated\n--- with t.",
	"timeTimeUnixMilli": "--- UnixMilli returns t as a Unix time, the number of milliseconds elapsed since\n--- January 1, 1970 UTC. The result is undefined if the Unix time in\n--- milliseconds cannot be represented by an int64 (a date more than 292 million\n--- years before or after 1970). The result does not depend on the\n--- location associated with t.",
	"timeTimeUnixNano": "--- UnixNano returns t as a Unix time, the number of nanoseconds elapsed\n--- since January 1, 1970 UTC. The result is undefined if the Unix time\n--- in nanoseconds cannot be represented by an int64 (a date before the year\n--- 1678 or after 2262). Note that this means the result of calling UnixNano\n--- on the zero Time is undefined. The result does not depend on the\n--- location associated with t.",
	"timeTimeUnmarshalBinary": "--- UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.",
	"timeTimeUnmarshalJSON": "--- UnmarshalJSON implements the json.Unmarshaler interface.\n--- The time must be a quoted string in the RFC 3339 format.",
	"timeTimeUnmarshalText": "--- UnmarshalText implements the encoding.TextUnmarshaler interface.\n--- The time must be in the RFC 3339 format.",
	"timeTimeWeekday": "--- Weekday returns the day of the week specified by t.",
	"timeTimeYear": "--- Year returns the year in which t occurs.",
	"timeTimeYearDay": "--- YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,\n--- and [1,366] in leap years.",
	"timeTimeZone": "--- Zone computes the time zone in effect at time t, returning the abbreviated\n--- name of the zone (such as \"CET\") and its offset in seconds east of UTC.",
	"timeTimeZoneBounds": "--- ZoneBounds returns the bounds of the time zone in effect at time t.\n--- The zone begins at start and the next zone begins at end.\n--- If the zone begins at the beginning of time, start will be returned as a zero Time.\n--- If the zone goes on forever, end will be returned as a zero Time.\n--- The Location of the returned times will be the same as t.",
	"timeTimeabs": "--- abs returns the time t as an absolute time, adjusted by the zone offset.\n--- It is called when computing a presentation property like Month or Hour.",
	"timeTimeaddSec": "--- addSec adds d seconds to the time.",
	"timeTimedate": "--- date computes the year, day of year, and when full=true,\n--- the month and day in which t occurs.",
	"timeTimelocabs": "--- locabs is a combination of the Zone and abs methods,\n--- extracting both return values from a single zone lookup.",
	"timeTimemono": "--- mono returns t's monotonic clock reading.\n--- It returns 0 for a missing reading.\n--- This function is used only for testing,\n--- so it's OK that technically 0 is a valid\n--- monotonic clock reading as well.",
	"timeTimensec": "--- nsec returns the time's nanoseconds.",
	"timeTimerReset": "--- Reset changes the timer to expire after duration d.\n--- It returns true if the timer had been active, false if the timer had\n--- expired or been stopped.\n---\n--- For a Timer created with NewTimer, Reset should be invoked only on\n--- stopped or expired timers with drained channels.\n---\n--- If a program has already received a value from t.C, the timer is known\n--- to have expired and the channel drained, so t.Reset can be used directly.\n--- If a program has not yet received a value from t.C, however,\n--- the timer must be stopped and—if Stop reports that the timer expired\n--- before being stopped—the channel explicitly drained:\n---\n---\tif !t.Stop() {\n---\t\t\u003c-t.C\n---\t}\n---\tt.Reset(d)\n---\n--- This should not be done concurrent to other receives from the Timer's\n--- channel.\n---\n--- Note that it is not possible to use Reset's return value correctly, as there\n--- is a race condition between draining the channel and the new timer expiring.\n--- Reset should always be invoked on stopped or expired channels, as described above.\n--- The return value exists to preserve compatibility with existing programs.\n---\n--- For a Timer created with AfterFunc(d, f), Reset either reschedules\n--- when f will run, in which case Reset returns true, or schedules f\n--- to run again, in which case it returns false.\n--- When Reset returns false, Reset neither waits for the prior f to\n--- complete before returning nor does it guarantee that the subsequent\n--- goroutine running f does not run concurrently with the prior\n--- one. If the caller needs to know whether the prior execution of\n--- f is completed, it must coordinate with f explicitly.",
	"timeTimerStop": "--- Stop prevents the Timer from firing.\n--- It returns true if the call stops the timer, false if the timer has already\n--- expired or been stopped.\n--- Stop does not close the channel, to prevent a read from the channel succeeding\n--- incorrectly.\n---\n--- To ensure the channel is empty after a call to Stop, check the\n--- return value and drain the channel.\n--- For example, assuming the program has not received from t.C already:\n---\n---\tif !t.Stop() {\n---\t\t\u003c-t.C\n---\t}\n---\n--- This cannot be done concurrent to other receives from the Timer's\n--- channel or other calls to the Timer's Stop method.\n---\n--- For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer\n--- has already expired and the function f has been started in its own goroutine;\n--- Stop does not wait for f to complete before returning.\n--- If the caller needs to know whether f is completed, it must coordinate\n--- with f explicitly.",
	"timeTimesec": "--- sec returns the time's seconds since Jan 1 year 1.",
	"timeTimesetLoc": "--- setLoc sets the location associated with the time.",
	"timeTimesetMono": "--- setMono sets the monotonic clock reading in t.\n--- If t cannot hold a monotonic clock reading,\n--- because its wall time is too large,\n--- setMono is a no-op.",
	"timeTimestripMono": "--- stripMono strips the monotonic clock reading in t.",
	"timeTimeunixSec": "--- unixSec returns the time's seconds since Jan 1 1970 (Unix time).",
	"timeUnix": "--- Unix returns the local Time corresponding to the given Unix time,\n--- sec seconds and nsec nanoseconds since January 1, 1970 UTC.\n--- It is valid to pass nsec outside the range [0, 999999999].\n--- Not all sec values have a corresponding time value. One such\n--- value is 1\u003c\u003c63-1 (the largest int64 value).",
	"timeUnixMicro": "--- UnixMicro returns the local Time corresponding to the given Unix time,\n--- usec microseconds since January 1, 1970 UTC.",
	"timeUnixMilli": "--- UnixMilli returns the local Time corresponding to the given Unix time,\n--- msec milliseconds since January 1, 1970 UTC.",
	"timeUntil": "--- Until returns the duration until t.\n--- It is shorthand for t.Sub(time.Now()).",
	"timeWeekdayString": "--- String returns the English name of the day (\"Sunday\", \"Monday\", ...)."
}