{
	"netAddrAppendTo": "--- AppendTo appends a text encoding of ip,\n--- as generated by MarshalText,\n--- to b and returns the extended buffer.",
	"netAddrAs16": "--- As16 returns the IP address in its 16-byte representation.\n--- IPv4 addresses are returned as IPv4-mapped IPv6 addresses.\n--- IPv6 addresses with zones are returned without their zone (use the\n--- Zone method to get it).\n--- The ip zero value returns all zeroes.",
	"netAddrAs4": "--- As4 returns an IPv4 or IPv4-in-IPv6 address in its 4-byte representation.\n--- If ip is the zero Addr or an IPv6 address, As4 panics.\n--- Note that 0.0.0.0 is not the zero Addr.",
	"netAddrAsSlice": "--- AsSlice returns an IPv4 or IPv6 address in its respective 4-byte or 16-byte representation.",
	"netAddrBitLen": "--- BitLen returns the number of bits in the IP address:\n--- 128 for IPv6, 32 for IPv4, and 0 for the zero Addr.\n---\n--- Note that IPv4-mapped IPv6 addresses are considered IPv6 addresses\n--- and therefore have bit length 128.",
	"netAddrCompare": "--- Compare returns an integer comparing two IPs.\n--- The result will be 0 if ip == ip2, -1 if ip \u003c ip2, and +1 if ip \u003e ip2.\n--- The definition of \"less than\" is the same as the Less method.",
	"netAddrIs4": "--- Is4 reports whether ip is an IPv4 address.\n---\n--- It returns false for IPv4-mapped IPv6 addresses. See Addr.Unmap.",
	"netAddrIs4In6": "--- Is4In6 reports whether ip is an IPv4-mapped IPv6 address.",
	"netAddrIs6": "--- Is6 reports whether ip is an IPv6 address, including IPv4-mapped\n--- IPv6 addresses.",
	"netAddrIsGlobalUnicast": "--- IsGlobalUnicast reports whether ip is a global unicast address.\n---\n--- It returns true for IPv6 addresses which fall outside of the current\n--- IANA-allocated 2000::/3 global unicast space, with the exception of the\n--- link-local address space. It also returns true even if ip is in the IPv4\n--- private address space or IPv6 unique local address space.\n--- It returns false for the zero Addr.\n---\n--- For reference, see RFC 1122, RFC 4291, and RFC 4632.",
	"netAddrIsInterfaceLocalMulticast": "--- IsInterfaceLocalMulticast reports whether ip is an IPv6 interface-local\n--- multicast address.",
	"netAddrIsLinkLocalMulticast": "--- IsLinkLocalMulticast reports whether ip is a link-local multicast address.",
	"netAddrIsLinkLocalUnicast": "--- IsLinkLocalUnicast reports whether ip is a link-local unicast address.",
	"netAddrIsLoopback": "--- IsLoopback reports whether ip is a loopback address.",
	"netAddrIsMulticast": "--- IsMulticast reports whether ip is a multicast address.",
	"netAddrIsPrivate": "--- IsPrivate reports whether ip is a private address, according to RFC 1918\n--- (IPv4 addresses) and RFC 4193 (IPv6 addresses). That is, it reports whether\n--- ip is in 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, or fc00::/7. This is the\n--- same as net.IP.IsPrivate.",
	"netAddrIsUnspecified": "--- IsUnspecified reports whether ip is an unspecified address, either the IPv4\n--- address \"0.0.0.0\" or the IPv6 address \"::\".\n---\n--- Note that the zero Addr is not an unspecified address.",
	"netAddrIsValid": "--- IsValid reports whether the Addr is an initialized address (not the zero Addr).\n---\n--- Note that \"0.0.0.0\" and \"::\" are both valid values.",
	"netAddrLess": "--- Less reports whether ip sorts before ip2.\n--- IP addresses sort first by length, then their address.\n--- IPv6 addresses with zones sort just after the same address without a zone.",
	"netAddrMarshalBinary": "--- MarshalBinary implements the encoding.BinaryMarshaler interface.\n--- It returns a zero-length slice for the zero Addr,\n--- the 4-byte form for an IPv4 address,\n--- and the 16-byte form with zone appended for an IPv6 address.",
	"netAddrMarshalText": "--- MarshalText implements the encoding.TextMarshaler interface,\n--- The encoding is the same as returned by String, with one exception:\n--- If ip is the zero Addr, the encoding is the empty string.",
	"netAddrNext": "--- Next returns the address following ip.\n--- If there is none, it returns the zero Addr.",
	"netAddrPrefix": "--- Prefix keeps only the top b bits of IP, producing a Prefix\n--- of the specified length.\n--- If ip is a zero Addr, Prefix always returns a zero Prefix and a nil error.\n--- Otherwise, if bits is less than zero or greater than ip.BitLen(),\n--- Prefix returns an error.",
	"netAddrPrev": "--- Prev returns the IP before ip.\n--- If there is none, it returns the IP zero value.",
	"netAddrString": "--- String returns the string form of the IP address ip.\n--- It returns one of 5 forms:\n---\n---   - \"invalid IP\", if ip is the zero Addr\n---   - IPv4 dotted decimal (\"192.0.2.1\")\n---   - IPv6 (\"2001:db8::1\")\n---   - \"::ffff:1.2.3.4\" (if Is4In6)\n---   - IPv6 with zone (\"fe80:db8::1%eth0\")\n---\n--- Note that unlike package net's IP.String method,\n--- IPv4-mapped IPv6 addresses format with a \"::ffff:\"\n--- prefix before the dotted quad.",
	"netAddrStringExpanded": "--- StringExpanded is like String but IPv6 addresses are expanded with leading\n--- zeroes and no \"::\" compression. For example, \"2001:db8::1\" becomes\n--- \"2001:0db8:0000:0000:0000:0000:0000:0001\".",
	"netAddrUnmap": "--- Unmap returns ip with any IPv4-mapped IPv6 address prefix removed.\n---\n--- That is, if ip is an IPv6 address wrapping an IPv4 address, it\n--- returns the wrapped IPv4 address. Otherwise it returns ip unmodified.",
	"netAddrUnmarshalBinary": "--- UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n--- It expects data in the form generated by MarshalBinary.",
	"netAddrUnmarshalText": "--- UnmarshalText implements the encoding.TextUnmarshaler interface.\n--- The IP address is expected in a form accepted by ParseAddr.\n---\n--- If text is empty, UnmarshalText sets *ip to the zero Addr and\n--- returns no error.",
	"netAddrWithZone": "--- WithZone returns an IP that's the same as ip but with the provided\n--- zone. If zone is empty, the zone is removed. If ip is an IPv4\n--- address, WithZone is a no-op and returns ip unchanged.",
	"netAddrZone": "--- Zone returns ip's IPv6 scoped addressing zone, if any.",
	"netAddrappendTo4": "",
	"netAddrappendTo6": "",
	"netAddrhasZone": "--- hasZone reports whether ip has an IPv6 zone.",
	"netAddrisZero": "--- isZero reports whether ip is the zero value of the IP type.\n--- The zero value is not a valid IP address of any type.\n---\n--- Note that \"0.0.0.0\" and \"::\" are not the zero value. Use IsUnspecified to\n--- check for these values instead.",
	"netAddrmarshalBinaryWithTrailingBytes": "",
	"netAddrstring4": "",
	"netAddrstring6": "--- string6 formats ip in IPv6 textual representation. It follows the\n--- guidelines in section 4 of RFC 5952\n--- (https://tools.ietf.org/html/rfc5952#section-4): no unnecessary\n--- zeros, use :: to elide the longest run of zeros, and don't use ::\n--- to compact a single zero field.",
	"netAddrv4": "--- v4 returns the i'th byte of ip. If ip is not an IPv4, v4 returns\n--- unspecified garbage.",
	"netAddrv6": "--- v6 returns the i'th byte of ip. If ip is an IPv4 address, this\n--- accesses the IPv4-mapped IPv6 address form of the IP.",
	"netAddrv6u16": "--- v6u16 returns the i'th 16-bit word of ip. If ip is an IPv4 address,\n--- this accesses the IPv4-mapped IPv6 address form of the IP.",
	"netAddrwithoutZone": "--- withoutZone unconditionally strips the zone from ip.\n--- It's similar to WithZone, but small enough to be inlinable.",
	"netipAddrFrom16": "--- AddrFrom16 returns the IPv6 address given by the bytes in addr.\n--- An IPv4-mapped IPv6 address is left as an IPv6 address.\n--- (Use Unmap to convert them if needed.)",
	"netipAddrFrom4": "--- AddrFrom4 returns the address of the IPv4 address given by the bytes in addr.",
	"netipAddrFromSlice": "--- AddrFromSlice parses the 4- or 16-byte byte slice as an IPv4 or IPv6 address.\n--- Note that a net.IP can be passed directly as the []byte argument.\n--- If slice's length is not 4 or 16, AddrFromSlice returns Addr{}, false.",
	"netipAddrPortAddr": "--- Addr returns p's IP address.",
	"netipAddrPortAppendTo": "--- AppendTo appends a text encoding of p,\n--- as generated by MarshalText,\n--- to b and returns the extended buffer.",
	"netipAddrPortFrom": "--- AddrPortFrom returns an AddrPort with the provided IP and port.\n--- It does not allocate.",
	"netipAddrPortIsValid": "--- IsValid reports whether p.Addr() is valid.\n--- All ports are valid, including zero.",
	"netipAddrPortMarshalBinary": "--- MarshalBinary implements the encoding.BinaryMarshaler interface.\n--- It returns Addr.MarshalBinary with an additional two bytes appended\n--- containing the port in little-endian.",
	"netipAddrPortMarshalText": "--- MarshalText implements the encoding.TextMarshaler interface. The\n--- encoding is the same as returned by String, with one exception: if\n--- p.Addr() is the zero Addr, the encoding is the empty string.",
	"netipAddrPortPort": "--- Port returns p's port.",
	"netipAddrPortString": "",
	"netipAddrPortUnmarshalBinary": "--- UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n--- It expects data in the form generated by MarshalBinary.",
	"netipAddrPortUnmarshalText": "--- UnmarshalText implements the encoding.TextUnmarshaler\n--- interface. The AddrPort is expected in a form\n--- generated by MarshalText or accepted by ParseAddrPort.",
	"netipIPv4Unspecified": "--- IPv4Unspecified returns the IPv4 unspecified address \"0.0.0.0\".",
	"netipIPv6LinkLocalAllNodes": "--- IPv6LinkLocalAllNodes returns the IPv6 link-local all nodes multicast\n--- address ff02::1.",
	"netipIPv6LinkLocalAllRouters": "--- IPv6LinkLocalAllRouters returns the IPv6 link-local all routers multicast\n--- address ff02::2.",
	"netipIPv6Loopback": "--- IPv6Loopback returns the IPv6 loopback address ::1.",
	"netipIPv6Unspecified": "--- IPv6Unspecified returns the IPv6 unspecified address \"::\".",
	"netipMustParseAddr": "--- MustParseAddr calls ParseAddr(s) and panics on error.\n--- It is intended for use in tests with hard-coded strings.",
	"netipMustParseAddrPort": "--- MustParseAddrPort calls ParseAddrPort(s) and panics on error.\n--- It is intended for use in tests with hard-coded strings.",
	"netipMustParsePrefix": "--- MustParsePrefix calls ParsePrefix(s) and panics on error.\n--- It is intended for use in tests with hard-coded strings.",
	"netipParseAddr": "--- ParseAddr parses s as an IP address, returning the result. The string\n--- s can be in dotted decimal (\"192.0.2.1\"), IPv6 (\"2001:db8::68\"),\n--- or IPv6 with a scoped addressing zone (\"fe80::1cc0:3e8c:119f:c2e1%ens18\").",
	"netipParseAddrPort": "--- ParseAddrPort parses s as an AddrPort.\n---\n--- It doesn't do any name resolution: both the address and the port\n--- must be numeric.",
	"netipParsePrefix": "--- ParsePrefix parses s as an IP address prefix.\n--- The string can be in the form \"192.168.1.0/24\" or \"2001:db8::/32\",\n--- the CIDR notation defined in RFC 4632 and RFC 4291.\n--- IPv6 zones are not permitted in prefixes, and an error will be returned if a\n--- zone is present.\n---\n--- Note that masked address bits are not zeroed. Use Masked for that.",
	"netipPrefixAddr": "--- Addr returns p's IP address.",
	"netipPrefixAppendTo": "--- AppendTo appends a text encoding of p,\n--- as generated by MarshalText,\n--- to b and returns the extended buffer.",
	"netipPrefixBits": "--- Bits returns p's prefix length.\n---\n--- It reports -1 if invalid.",
	"netipPrefixContains": "--- Contains reports whether the network p includes ip.\n---\n--- An IPv4 address will not match an IPv6 prefix.\n--- An IPv4-mapped IPv6 address will not match an IPv4 prefix.\n--- A zero-value IP will not match any prefix.\n--- If ip has an IPv6 zone, Contains returns false,\n--- because Prefixes strip zones.",
	"netipPrefixFrom": "--- PrefixFrom returns a Prefix with the provided IP address and bit\n--- prefix length.\n---\n--- It does not allocate. Unlike Addr.Prefix, PrefixFrom does not mask\n--- off the host bits of ip.\n---\n--- If bits is less than zero or greater than ip.BitLen, Prefix.Bits\n--- will return an invalid value -1.",
	"netipPrefixIsSingleIP": "--- IsSingleIP reports whether p contains exactly one IP.",
	"netipPrefixIsValid": "--- IsValid reports whether p.Bits() has a valid range for p.Addr().\n--- If p.Addr() is the zero Addr, IsValid returns false.\n--- Note that if p is the zero Prefix, then p.IsValid() == false.",
	"netipPrefixMarshalBinary": "--- MarshalBinary implements the encoding.BinaryMarshaler interface.\n--- It returns Addr.MarshalBinary with an additional byte appended\n--- containing the prefix bits.",
	"netipPrefixMarshalText": "--- MarshalText implements the encoding.TextMarshaler interface,\n--- The encoding is the same as returned by String, with one exception:\n--- If p is the zero value, the encoding is the empty string.",
	"netipPrefixMasked": "--- Masked returns p in its canonical form, with all but the high\n--- p.Bits() bits of p.Addr() masked off.\n---\n--- If p is zero or otherwise invalid, Masked returns the zero Prefix.",
	"netipPrefixOverlaps": "--- Overlaps reports whether p and o contain any IP addresses in common.\n---\n--- If p and o are of different address families or either have a zero\n--- IP, it reports false. Like the Contains method, a prefix with an\n--- IPv4-mapped IPv6 address is still treated as an IPv6 mask.",
	"netipPrefixString": "--- String returns the CIDR notation of p: \"\u003cip\u003e/\u003cbits\u003e\".",
	"netipPrefixUnmarshalBinary": "--- UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n--- It expects data in the form generated by MarshalBinary.",
	"netipPrefixUnmarshalText": "--- UnmarshalText implements the encoding.TextUnmarshaler interface.\n--- The IP address is expected in a form accepted by ParsePrefix\n--- or generated by MarshalText.",
	"netipPrefixisZero": ""
}