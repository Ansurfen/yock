{
	"httpAllowQuerySemicolons": "--- AllowQuerySemicolons returns a handler that serves requests by converting any\n--- unescaped semicolons in the URL query to ampersands, and invoking the handler h.\n---\n--- This restores the pre-Go 1.17 behavior of splitting query parameters on both\n--- semicolons and ampersands. (See golang.org/issue/25192). Note that this\n--- behavior doesn't match that of many proxies, and the mismatch can lead to\n--- security issues.\n---\n--- AllowQuerySemicolons should be invoked before Request.ParseForm is called.",
	"httpArgServer": "--- simple argument server",
	"httpCanonicalHeaderKey": "--- CanonicalHeaderKey returns the canonical format of the\n--- header key s. The canonicalization converts the first\n--- letter and any letter following a hyphen to upper case;\n--- the rest are converted to lowercase. For example, the\n--- canonical key for \"accept-encoding\" is \"Accept-Encoding\".\n--- If s contains a space or invalid header field bytes, it is\n--- returned without modifications.",
	"httpChanCreate": "",
	"httpChanServeHTTP": "",
	"httpClientCloseIdleConnections": "--- CloseIdleConnections closes any connections on its Transport which\n--- were previously connected from previous requests but are now\n--- sitting idle in a \"keep-alive\" state. It does not interrupt any\n--- connections currently in use.\n---\n--- If the Client's Transport does not have a CloseIdleConnections method\n--- then this method does nothing.",
	"httpClientDo": "--- Do sends an HTTP request and returns an HTTP response, following\n--- policy (such as redirects, cookies, auth) as configured on the\n--- client.\n---\n--- An error is returned if caused by client policy (such as\n--- CheckRedirect), or failure to speak HTTP (such as a network\n--- connectivity problem). A non-2xx status code doesn't cause an\n--- error.\n---\n--- If the returned error is nil, the Response will contain a non-nil\n--- Body which the user is expected to close. If the Body is not both\n--- read to EOF and closed, the Client's underlying RoundTripper\n--- (typically Transport) may not be able to re-use a persistent TCP\n--- connection to the server for a subsequent \"keep-alive\" request.\n---\n--- The request Body, if non-nil, will be closed by the underlying\n--- Transport, even on errors.\n---\n--- On error, any Response can be ignored. A non-nil Response with a\n--- non-nil error only occurs when CheckRedirect fails, and even then\n--- the returned Response.Body is already closed.\n---\n--- Generally Get, Post, or PostForm will be used instead of Do.\n---\n--- If the server replies with a redirect, the Client first uses the\n--- CheckRedirect function to determine whether the redirect should be\n--- followed. If permitted, a 301, 302, or 303 redirect causes\n--- subsequent requests to use HTTP method GET\n--- (or HEAD if the original request was HEAD), with no body.\n--- A 307 or 308 redirect preserves the original HTTP method and body,\n--- provided that the Request.GetBody function is defined.\n--- The NewRequest function automatically sets GetBody for common\n--- standard library body types.\n---\n--- Any returned error will be of type *url.Error. The url.Error\n--- value's Timeout method will report true if the request timed out.",
	"httpClientGet": "--- Get issues a GET to the specified URL. If the response is one of the\n--- following redirect codes, Get follows the redirect after calling the\n--- Client's CheckRedirect function:\n---\n---\t301 (Moved Permanently)\n---\t302 (Found)\n---\t303 (See Other)\n---\t307 (Temporary Redirect)\n---\t308 (Permanent Redirect)\n---\n--- An error is returned if the Client's CheckRedirect function fails\n--- or if there was an HTTP protocol error. A non-2xx response doesn't\n--- cause an error. Any returned error will be of type *url.Error. The\n--- url.Error value's Timeout method will report true if the request\n--- timed out.\n---\n--- When err is nil, resp always contains a non-nil resp.Body.\n--- Caller should close resp.Body when done reading from it.\n---\n--- To make a request with custom headers, use NewRequest and Client.Do.\n---\n--- To make a request with a specified context.Context, use NewRequestWithContext\n--- and Client.Do.",
	"httpClientHead": "--- Head issues a HEAD to the specified URL. If the response is one of the\n--- following redirect codes, Head follows the redirect after calling the\n--- Client's CheckRedirect function:\n---\n---\t301 (Moved Permanently)\n---\t302 (Found)\n---\t303 (See Other)\n---\t307 (Temporary Redirect)\n---\t308 (Permanent Redirect)\n---\n--- To make a request with a specified context.Context, use NewRequestWithContext\n--- and Client.Do.",
	"httpClientPost": "--- Post issues a POST to the specified URL.\n---\n--- Caller should close resp.Body when done reading from it.\n---\n--- If the provided body is an io.Closer, it is closed after the\n--- request.\n---\n--- To set custom headers, use NewRequest and Client.Do.\n---\n--- To make a request with a specified context.Context, use NewRequestWithContext\n--- and Client.Do.\n---\n--- See the Client.Do method documentation for details on how redirects\n--- are handled.",
	"httpClientPostForm": "--- PostForm issues a POST to the specified URL,\n--- with data's keys and values URL-encoded as the request body.\n---\n--- The Content-Type header is set to application/x-www-form-urlencoded.\n--- To set other headers, use NewRequest and Client.Do.\n---\n--- When err is nil, resp always contains a non-nil resp.Body.\n--- Caller should close resp.Body when done reading from it.\n---\n--- See the Client.Do method documentation for details on how redirects\n--- are handled.\n---\n--- To make a request with a specified context.Context, use NewRequestWithContext\n--- and Client.Do.",
	"httpClientcheckRedirect": "--- checkRedirect calls either the user's configured CheckRedirect\n--- function, or the default.",
	"httpClientdeadline": "",
	"httpClientdo": "",
	"httpClientmakeHeadersCopier": "--- makeHeadersCopier makes a function that copies headers from the\n--- initial Request, ireq. For every redirect, this function must be called\n--- so that it can copy headers into the upcoming Request.",
	"httpClientsend": "--- didTimeout is non-nil only if err != nil.",
	"httpClienttransport": "",
	"httpConnStateString": "",
	"httpCookieString": "--- String returns the serialization of the cookie for use in a Cookie\n--- header (if only Name and Value are set) or a Set-Cookie response\n--- header (if other fields are set).\n--- If c is nil or c.Name is invalid, the empty string is returned.",
	"httpCookieValid": "--- Valid reports whether the cookie is valid.",
	"httpCounterServeHTTP": "",
	"httpCounterString": "--- This makes Counter satisfy the expvar.Var interface, so we can export\n--- it directly.",
	"httpDateServer": "--- exec a program, redirecting output.",
	"httpDetectContentType": "--- DetectContentType implements the algorithm described\n--- at https://mimesniff.spec.whatwg.org/ to determine the\n--- Content-Type of the given data. It considers at most the\n--- first 512 bytes of data. DetectContentType always returns\n--- a valid MIME type: if it cannot determine a more specific one, it\n--- returns \"application/octet-stream\".",
	"httpDirOpen": "--- Open implements FileSystem using os.Open, opening files for reading rooted\n--- and relative to the directory d.",
	"httpError": "--- Error replies to the request with the specified error message and HTTP code.\n--- It does not otherwise end the request; the caller should ensure no further\n--- writes are done to w.\n--- The error message should be plain text.",
	"httpFS": "--- FS converts fsys to a FileSystem implementation,\n--- for use with FileServer and NewFileTransport.\n--- The files provided by fsys must implement io.Seeker.",
	"httpFileServer": "--- FileServer returns a handler that serves HTTP requests\n--- with the contents of the file system rooted at root.\n---\n--- As a special case, the returned file server redirects any request\n--- ending in \"/index.html\" to the same path, without the final\n--- \"index.html\".\n---\n--- To use the operating system's file system implementation,\n--- use http.Dir:\n---\n---\thttp.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n---\n--- To use an fs.FS implementation, use http.FS to convert it:\n---\n---\thttp.Handle(\"/\", http.FileServer(http.FS(fsys)))",
	"httpFlagServer": "",
	"httpGet": "--- Get issues a GET to the specified URL. If the response is one of\n--- the following redirect codes, Get follows the redirect, up to a\n--- maximum of 10 redirects:\n---\n---\t301 (Moved Permanently)\n---\t302 (Found)\n---\t303 (See Other)\n---\t307 (Temporary Redirect)\n---\t308 (Permanent Redirect)\n---\n--- An error is returned if there were too many redirects or if there\n--- was an HTTP protocol error. A non-2xx response doesn't cause an\n--- error. Any returned error will be of type *url.Error. The url.Error\n--- value's Timeout method will report true if the request timed out.\n---\n--- When err is nil, resp always contains a non-nil resp.Body.\n--- Caller should close resp.Body when done reading from it.\n---\n--- Get is a wrapper around DefaultClient.Get.\n---\n--- To make a request with custom headers, use NewRequest and\n--- DefaultClient.Do.\n---\n--- To make a request with a specified context.Context, use NewRequestWithContext\n--- and DefaultClient.Do.",
	"httpHandle": "--- Handle registers the handler for the given pattern\n--- in the DefaultServeMux.\n--- The documentation for ServeMux explains how patterns are matched.",
	"httpHandleFunc": "--- HandleFunc registers the handler function for the given pattern\n--- in the DefaultServeMux.\n--- The documentation for ServeMux explains how patterns are matched.",
	"httpHandlerFuncServeHTTP": "--- ServeHTTP calls f(w, r).",
	"httpHead": "--- Head issues a HEAD to the specified URL. If the response is one of\n--- the following redirect codes, Head follows the redirect, up to a\n--- maximum of 10 redirects:\n---\n---\t301 (Moved Permanently)\n---\t302 (Found)\n---\t303 (See Other)\n---\t307 (Temporary Redirect)\n---\t308 (Permanent Redirect)\n---\n--- Head is a wrapper around DefaultClient.Head.\n---\n--- To make a request with a specified context.Context, use NewRequestWithContext\n--- and DefaultClient.Do.",
	"httpHeaderAdd": "--- Add adds the key, value pair to the header.\n--- It appends to any existing values associated with key.\n--- The key is case insensitive; it is canonicalized by\n--- CanonicalHeaderKey.",
	"httpHeaderClone": "--- Clone returns a copy of h or nil if h is nil.",
	"httpHeaderDel": "--- Del deletes the values associated with key.\n--- The key is case insensitive; it is canonicalized by\n--- CanonicalHeaderKey.",
	"httpHeaderGet": "--- Get gets the first value associated with the given key. If\n--- there are no values associated with the key, Get returns \"\".\n--- It is case insensitive; textproto.CanonicalMIMEHeaderKey is\n--- used to canonicalize the provided key. Get assumes that all\n--- keys are stored in canonical form. To use non-canonical keys,\n--- access the map directly.",
	"httpHeaderSet": "--- Set sets the header entries associated with key to the\n--- single element value. It replaces any existing values\n--- associated with key. The key is case insensitive; it is\n--- canonicalized by textproto.CanonicalMIMEHeaderKey.\n--- To use non-canonical keys, assign to the map directly.",
	"httpHeaderValues": "--- Values returns all values associated with the given key.\n--- It is case insensitive; textproto.CanonicalMIMEHeaderKey is\n--- used to canonicalize the provided key. To use non-canonical\n--- keys, access the map directly.\n--- The returned slice is not a copy.",
	"httpHeaderWrite": "--- Write writes a header in wire format.",
	"httpHeaderWriteSubset": "--- WriteSubset writes a header in wire format.\n--- If exclude is not nil, keys where exclude[key] == true are not written.\n--- Keys are not canonicalized before checking the exclude map.",
	"httpHeaderget": "--- get is like Get, but key must already be in CanonicalHeaderKey form.",
	"httpHeaderhas": "--- has reports whether h has the provided key defined, even if it's\n--- set to 0-length slice.",
	"httpHeadersortedKeyValues": "--- sortedKeyValues returns h's keys sorted in the returned kvs\n--- slice. The headerSorter used to sort is also returned, for possible\n--- return to headerSorterCache.",
	"httpHeaderwrite": "",
	"httpHeaderwriteSubset": "",
	"httpHelloServer": "",
	"httpListenAndServe": "--- ListenAndServe listens on the TCP network address addr and then calls\n--- Serve with handler to handle requests on incoming connections.\n--- Accepted connections are configured to enable TCP keep-alives.\n---\n--- The handler is typically nil, in which case the DefaultServeMux is used.\n---\n--- ListenAndServe always returns a non-nil error.",
	"httpListenAndServeTLS": "--- ListenAndServeTLS acts identically to ListenAndServe, except that it\n--- expects HTTPS connections. Additionally, files containing a certificate and\n--- matching private key for the server must be provided. If the certificate\n--- is signed by a certificate authority, the certFile should be the concatenation\n--- of the server's certificate, any intermediates, and the CA's certificate.",
	"httpLogger": "",
	"httpMaxBytesErrorError": "",
	"httpMaxBytesHandler": "--- MaxBytesHandler returns a Handler that runs h with its ResponseWriter and Request.Body wrapped by a MaxBytesReader.",
	"httpMaxBytesReader": "--- MaxBytesReader is similar to io.LimitReader but is intended for\n--- limiting the size of incoming request bodies. In contrast to\n--- io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\n--- non-nil error of type *MaxBytesError for a Read beyond the limit,\n--- and closes the underlying reader when its Close method is called.\n---\n--- MaxBytesReader prevents clients from accidentally or maliciously\n--- sending a large request and wasting server resources. If possible,\n--- it tells the ResponseWriter to close the connection after the limit\n--- has been reached.",
	"httpNewFileTransport": "--- NewFileTransport returns a new RoundTripper, serving the provided\n--- FileSystem. The returned RoundTripper ignores the URL host in its\n--- incoming requests, as well as most other properties of the\n--- request.\n---\n--- The typical use case for NewFileTransport is to register the \"file\"\n--- protocol with a Transport, as in:\n---\n---\tt := \u0026http.Transport{}\n---\tt.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n---\tc := \u0026http.Client{Transport: t}\n---\tres, err := c.Get(\"file:///etc/passwd\")\n---\t...",
	"httpNewRequest": "--- NewRequest wraps NewRequestWithContext using context.Background.",
	"httpNewRequestWithContext": "--- NewRequestWithContext returns a new Request given a method, URL, and\n--- optional body.\n---\n--- If the provided body is also an io.Closer, the returned\n--- Request.Body is set to body and will be closed by the Client\n--- methods Do, Post, and PostForm, and Transport.RoundTrip.\n---\n--- NewRequestWithContext returns a Request suitable for use with\n--- Client.Do or Transport.RoundTrip. To create a request for use with\n--- testing a Server Handler, either use the NewRequest function in the\n--- net/http/httptest package, use ReadRequest, or manually update the\n--- Request fields. For an outgoing client request, the context\n--- controls the entire lifetime of a request and its response:\n--- obtaining a connection, sending the request, and reading the\n--- response headers and body. See the Request type's documentation for\n--- the difference between inbound and outbound request fields.\n---\n--- If body is of type *bytes.Buffer, *bytes.Reader, or\n--- *strings.Reader, the returned request's ContentLength is set to its\n--- exact value (instead of -1), GetBody is populated (so 307 and 308\n--- redirects can replay the body), and Body is set to NoBody if the\n--- ContentLength is 0.",
	"httpNewResponseController": "--- NewResponseController creates a ResponseController for a request.\n---\n--- The ResponseWriter should be the original value passed to the Handler.ServeHTTP method,\n--- or have an Unwrap method returning the original ResponseWriter.\n---\n--- If the ResponseWriter implements any of the following methods, the ResponseController\n--- will call them as appropriate:\n---\n---\tFlush()\n---\tFlushError() error // alternative Flush returning an error\n---\tHijack() (net.Conn, *bufio.ReadWriter, error)\n---\tSetReadDeadline(deadline time.Time) error\n---\tSetWriteDeadline(deadline time.Time) error\n---\n--- If the ResponseWriter does not support a method, ResponseController returns\n--- an error matching ErrNotSupported.",
	"httpNewServeMux": "--- NewServeMux allocates and returns a new ServeMux.",
	"httpNotFound": "--- NotFound replies to the request with an HTTP 404 not found error.",
	"httpNotFoundHandler": "--- NotFoundHandler returns a simple request handler\n--- that replies to each request with a “404 page not found” reply.",
	"httpParseHTTPVersion": "--- ParseHTTPVersion parses an HTTP version string according to RFC 7230, section 2.6.\n--- \"HTTP/1.0\" returns (1, 0, true). Note that strings without\n--- a minor version, such as \"HTTP/2\", are not valid.",
	"httpParseTime": "--- ParseTime parses a time header (such as the Date: header),\n--- trying each of the three formats allowed by HTTP/1.1:\n--- TimeFormat, time.RFC850, and time.ANSIC.",
	"httpPost": "--- Post issues a POST to the specified URL.\n---\n--- Caller should close resp.Body when done reading from it.\n---\n--- If the provided body is an io.Closer, it is closed after the\n--- request.\n---\n--- Post is a wrapper around DefaultClient.Post.\n---\n--- To set custom headers, use NewRequest and DefaultClient.Do.\n---\n--- See the Client.Do method documentation for details on how redirects\n--- are handled.\n---\n--- To make a request with a specified context.Context, use NewRequestWithContext\n--- and DefaultClient.Do.",
	"httpPostForm": "--- PostForm issues a POST to the specified URL, with data's keys and\n--- values URL-encoded as the request body.\n---\n--- The Content-Type header is set to application/x-www-form-urlencoded.\n--- To set other headers, use NewRequest and DefaultClient.Do.\n---\n--- When err is nil, resp always contains a non-nil resp.Body.\n--- Caller should close resp.Body when done reading from it.\n---\n--- PostForm is a wrapper around DefaultClient.PostForm.\n---\n--- See the Client.Do method documentation for details on how redirects\n--- are handled.\n---\n--- To make a request with a specified context.Context, use NewRequestWithContext\n--- and DefaultClient.Do.",
	"httpProtocolErrorError": "",
	"httpProxyFromEnvironment": "--- ProxyFromEnvironment returns the URL of the proxy to use for a\n--- given request, as indicated by the environment variables\n--- HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\n--- thereof). Requests use the proxy from the environment variable\n--- matching their scheme, unless excluded by NO_PROXY.\n---\n--- The environment values may be either a complete URL or a\n--- \"host[:port]\", in which case the \"http\" scheme is assumed.\n--- The schemes \"http\", \"https\", and \"socks5\" are supported.\n--- An error is returned if the value is a different form.\n---\n--- A nil URL and nil error are returned if no proxy is defined in the\n--- environment, or a proxy should not be used for the given request,\n--- as defined by NO_PROXY.\n---\n--- As a special case, if req.URL.Host is \"localhost\" (with or without\n--- a port number), then a nil URL and nil error will be returned.",
	"httpProxyURL": "--- ProxyURL returns a proxy function (for use in a Transport)\n--- that always returns the same URL.",
	"httpReadRequest": "--- ReadRequest reads and parses an incoming request from b.\n---\n--- ReadRequest is a low-level function and should only be used for\n--- specialized applications; most code should use the Server to read\n--- requests and handle them via the Handler interface. ReadRequest\n--- only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.",
	"httpReadResponse": "--- ReadResponse reads and returns an HTTP response from r.\n--- The req parameter optionally specifies the Request that corresponds\n--- to this Response. If nil, a GET request is assumed.\n--- Clients must call resp.Body.Close when finished reading resp.Body.\n--- After that call, clients can inspect resp.Trailer to find key/value\n--- pairs included in the response trailer.",
	"httpRedirect": "--- Redirect replies to the request with a redirect to url,\n--- which may be a path relative to the request path.\n---\n--- The provided code should be in the 3xx range and is usually\n--- StatusMovedPermanently, StatusFound or StatusSeeOther.\n---\n--- If the Content-Type header has not been set, Redirect sets it\n--- to \"text/html; charset=utf-8\" and writes a small HTML body.\n--- Setting the Content-Type header to any value, including nil,\n--- disables that behavior.",
	"httpRedirectHandler": "--- RedirectHandler returns a request handler that redirects\n--- each request it receives to the given url using the given\n--- status code.\n---\n--- The provided code should be in the 3xx range and is usually\n--- StatusMovedPermanently, StatusFound or StatusSeeOther.",
	"httpRequestAddCookie": "--- AddCookie adds a cookie to the request. Per RFC 6265 section 5.4,\n--- AddCookie does not attach more than one Cookie header field. That\n--- means all cookies, if any, are written into the same line,\n--- separated by semicolon.\n--- AddCookie only sanitizes c's name and value, and does not sanitize\n--- a Cookie header already present in the request.",
	"httpRequestBasicAuth": "--- BasicAuth returns the username and password provided in the request's\n--- Authorization header, if the request uses HTTP Basic Authentication.\n--- See RFC 2617, Section 2.",
	"httpRequestClone": "--- Clone returns a deep copy of r with its context changed to ctx.\n--- The provided ctx must be non-nil.\n---\n--- For an outgoing client request, the context controls the entire\n--- lifetime of a request and its response: obtaining a connection,\n--- sending the request, and reading the response headers and body.",
	"httpRequestContext": "--- Context returns the request's context. To change the context, use\n--- Clone or WithContext.\n---\n--- The returned context is always non-nil; it defaults to the\n--- background context.\n---\n--- For outgoing client requests, the context controls cancellation.\n---\n--- For incoming server requests, the context is canceled when the\n--- client's connection closes, the request is canceled (with HTTP/2),\n--- or when the ServeHTTP method returns.",
	"httpRequestCookie": "--- Cookie returns the named cookie provided in the request or\n--- ErrNoCookie if not found.\n--- If multiple cookies match the given name, only one cookie will\n--- be returned.",
	"httpRequestCookies": "--- Cookies parses and returns the HTTP cookies sent with the request.",
	"httpRequestFormFile": "--- FormFile returns the first file for the provided form key.\n--- FormFile calls ParseMultipartForm and ParseForm if necessary.",
	"httpRequestFormValue": "--- FormValue returns the first value for the named component of the query.\n--- POST and PUT body parameters take precedence over URL query string values.\n--- FormValue calls ParseMultipartForm and ParseForm if necessary and ignores\n--- any errors returned by these functions.\n--- If key is not present, FormValue returns the empty string.\n--- To access multiple values of the same key, call ParseForm and\n--- then inspect Request.Form directly.",
	"httpRequestMultipartReader": "--- MultipartReader returns a MIME multipart reader if this is a\n--- multipart/form-data or a multipart/mixed POST request, else returns nil and an error.\n--- Use this function instead of ParseMultipartForm to\n--- process the request body as a stream.",
	"httpRequestParseForm": "--- ParseForm populates r.Form and r.PostForm.\n---\n--- For all requests, ParseForm parses the raw query from the URL and updates\n--- r.Form.\n---\n--- For POST, PUT, and PATCH requests, it also reads the request body, parses it\n--- as a form and puts the results into both r.PostForm and r.Form. Request body\n--- parameters take precedence over URL query string values in r.Form.\n---\n--- If the request Body's size has not already been limited by MaxBytesReader,\n--- the size is capped at 10MB.\n---\n--- For other HTTP methods, or when the Content-Type is not\n--- application/x-www-form-urlencoded, the request Body is not read, and\n--- r.PostForm is initialized to a non-nil, empty value.\n---\n--- ParseMultipartForm calls ParseForm automatically.\n--- ParseForm is idempotent.",
	"httpRequestParseMultipartForm": "--- ParseMultipartForm parses a request body as multipart/form-data.\n--- The whole request body is parsed and up to a total of maxMemory bytes of\n--- its file parts are stored in memory, with the remainder stored on\n--- disk in temporary files.\n--- ParseMultipartForm calls ParseForm if necessary.\n--- If ParseForm returns an error, ParseMultipartForm returns it but also\n--- continues parsing the request body.\n--- After one call to ParseMultipartForm, subsequent calls have no effect.",
	"httpRequestPostFormValue": "--- PostFormValue returns the first value for the named component of the POST,\n--- PATCH, or PUT request body. URL query parameters are ignored.\n--- PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores\n--- any errors returned by these functions.\n--- If key is not present, PostFormValue returns the empty string.",
	"httpRequestProtoAtLeast": "--- ProtoAtLeast reports whether the HTTP protocol used\n--- in the request is at least major.minor.",
	"httpRequestReferer": "--- Referer returns the referring URL, if sent in the request.\n---\n--- Referer is misspelled as in the request itself, a mistake from the\n--- earliest days of HTTP.  This value can also be fetched from the\n--- Header map as Header[\"Referer\"]; the benefit of making it available\n--- as a method is that the compiler can diagnose programs that use the\n--- alternate (correct English) spelling req.Referrer() but cannot\n--- diagnose programs that use Header[\"Referrer\"].",
	"httpRequestSetBasicAuth": "--- SetBasicAuth sets the request's Authorization header to use HTTP\n--- Basic Authentication with the provided username and password.\n---\n--- With HTTP Basic Authentication the provided username and password\n--- are not encrypted. It should generally only be used in an HTTPS\n--- request.\n---\n--- The username may not contain a colon. Some protocols may impose\n--- additional requirements on pre-escaping the username and\n--- password. For instance, when used with OAuth2, both arguments must\n--- be URL encoded first with url.QueryEscape.",
	"httpRequestUserAgent": "--- UserAgent returns the client's User-Agent, if sent in the request.",
	"httpRequestWithContext": "--- WithContext returns a shallow copy of r with its context changed\n--- to ctx. The provided ctx must be non-nil.\n---\n--- For outgoing client request, the context controls the entire\n--- lifetime of a request and its response: obtaining a connection,\n--- sending the request, and reading the response headers and body.\n---\n--- To create a new request with a context, use NewRequestWithContext.\n--- To make a deep copy of a request with a new context, use Request.Clone.",
	"httpRequestWrite": "--- Write writes an HTTP/1.1 request, which is the header and body, in wire format.\n--- This method consults the following fields of the request:\n---\n---\tHost\n---\tURL\n---\tMethod (defaults to \"GET\")\n---\tHeader\n---\tContentLength\n---\tTransferEncoding\n---\tBody\n---\n--- If Body is present, Content-Length is \u003c= 0 and TransferEncoding\n--- hasn't been set to \"identity\", Write adds \"Transfer-Encoding:\n--- chunked\" to the header. Body is closed after it is sent.",
	"httpRequestWriteProxy": "--- WriteProxy is like Write but writes the request in the form\n--- expected by an HTTP proxy. In particular, WriteProxy writes the\n--- initial Request-URI line of the request with an absolute URI, per\n--- section 5.3 of RFC 7230, including the scheme and host.\n--- In either case, WriteProxy also writes a Host header, using\n--- either r.Host or r.URL.Host.",
	"httpRequestcloseBody": "",
	"httpRequestexpectsContinue": "",
	"httpRequestisH2Upgrade": "--- isH2Upgrade reports whether r represents the http2 \"client preface\"\n--- magic string.",
	"httpRequestisReplayable": "",
	"httpRequestmultipartReader": "",
	"httpRequestoutgoingLength": "--- outgoingLength reports the Content-Length of this outgoing (Client) request.\n--- It maps 0 into -1 (unknown) when the Body is non-nil.",
	"httpRequestrequiresHTTP1": "--- requiresHTTP1 reports whether this request requires being sent on\n--- an HTTP/1 connection.",
	"httpRequestwantsClose": "",
	"httpRequestwantsHttp10KeepAlive": "",
	"httpRequestwrite": "--- extraHeaders may be nil\n--- waitForContinue may be nil\n--- always closes body",
	"httpResponseControllerFlush": "--- Flush flushes buffered data to the client.",
	"httpResponseControllerHijack": "--- Hijack lets the caller take over the connection.\n--- See the Hijacker interface for details.",
	"httpResponseControllerSetReadDeadline": "--- SetReadDeadline sets the deadline for reading the entire request, including the body.\n--- Reads from the request body after the deadline has been exceeded will return an error.\n--- A zero value means no deadline.\n---\n--- Setting the read deadline after it has been exceeded will not extend it.",
	"httpResponseControllerSetWriteDeadline": "--- SetWriteDeadline sets the deadline for writing the response.\n--- Writes to the response body after the deadline has been exceeded will not block,\n--- but may succeed if the data has been buffered.\n--- A zero value means no deadline.\n---\n--- Setting the write deadline after it has been exceeded will not extend it.",
	"httpResponseCookies": "--- Cookies parses and returns the cookies set in the Set-Cookie headers.",
	"httpResponseLocation": "--- Location returns the URL of the response's \"Location\" header,\n--- if present. Relative redirects are resolved relative to\n--- the Response's Request. ErrNoLocation is returned if no\n--- Location header is present.",
	"httpResponseProtoAtLeast": "--- ProtoAtLeast reports whether the HTTP protocol used\n--- in the response is at least major.minor.",
	"httpResponseWrite": "--- Write writes r to w in the HTTP/1.x server response format,\n--- including the status line, headers, body, and optional trailer.\n---\n--- This method consults the following fields of the response r:\n---\n---\tStatusCode\n---\tProtoMajor\n---\tProtoMinor\n---\tRequest.Method\n---\tTransferEncoding\n---\tTrailer\n---\tBody\n---\tContentLength\n---\tHeader, values for non-canonical keys will have unpredictable behavior\n---\n--- The Response Body is closed after it is sent.",
	"httpResponsebodyIsWritable": "--- bodyIsWritable reports whether the Body supports writing. The\n--- Transport returns Writable bodies for 101 Switching Protocols\n--- responses.\n--- The Transport uses this method to determine whether a persistent\n--- connection is done being managed from its perspective. Once we\n--- return a writable response body to a user, the net/http package is\n--- done managing that connection.",
	"httpResponsecloseBody": "",
	"httpResponseisProtocolSwitch": "--- isProtocolSwitch reports whether the response code and header\n--- indicate a successful protocol upgrade response.",
	"httpServe": "--- Serve accepts incoming HTTP connections on the listener l,\n--- creating a new service goroutine for each. The service goroutines\n--- read requests and then call handler to reply to them.\n---\n--- The handler is typically nil, in which case the DefaultServeMux is used.\n---\n--- HTTP/2 support is only enabled if the Listener returns *tls.Conn\n--- connections and they were configured with \"h2\" in the TLS\n--- Config.NextProtos.\n---\n--- Serve always returns a non-nil error.",
	"httpServeContent": "--- ServeContent replies to the request using the content in the\n--- provided ReadSeeker. The main benefit of ServeContent over io.Copy\n--- is that it handles Range requests properly, sets the MIME type, and\n--- handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\n--- and If-Range requests.\n---\n--- If the response's Content-Type header is not set, ServeContent\n--- first tries to deduce the type from name's file extension and,\n--- if that fails, falls back to reading the first block of the content\n--- and passing it to DetectContentType.\n--- The name is otherwise unused; in particular it can be empty and is\n--- never sent in the response.\n---\n--- If modtime is not the zero time or Unix epoch, ServeContent\n--- includes it in a Last-Modified header in the response. If the\n--- request includes an If-Modified-Since header, ServeContent uses\n--- modtime to decide whether the content needs to be sent at all.\n---\n--- The content's Seek method must work: ServeContent uses\n--- a seek to the end of the content to determine its size.\n---\n--- If the caller has set w's ETag header formatted per RFC 7232, section 2.3,\n--- ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n---\n--- Note that *os.File implements the io.ReadSeeker interface.",
	"httpServeFile": "--- ServeFile replies to the request with the contents of the named\n--- file or directory.\n---\n--- If the provided file or directory name is a relative path, it is\n--- interpreted relative to the current directory and may ascend to\n--- parent directories. If the provided name is constructed from user\n--- input, it should be sanitized before calling ServeFile.\n---\n--- As a precaution, ServeFile will reject requests where r.URL.Path\n--- contains a \"..\" path element; this protects against callers who\n--- might unsafely use filepath.Join on r.URL.Path without sanitizing\n--- it and then use that filepath.Join result as the name argument.\n---\n--- As another special case, ServeFile redirects any request where r.URL.Path\n--- ends in \"/index.html\" to the same path, without the final\n--- \"index.html\". To avoid such redirects either modify the path or\n--- use ServeContent.\n---\n--- Outside of those two special cases, ServeFile does not use\n--- r.URL.Path for selecting the file or directory to serve; only the\n--- file or directory provided in the name argument is used.",
	"httpServeMuxHandle": "--- Handle registers the handler for the given pattern.\n--- If a handler already exists for pattern, Handle panics.",
	"httpServeMuxHandleFunc": "--- HandleFunc registers the handler function for the given pattern.",
	"httpServeMuxHandler": "--- Handler returns the handler to use for the given request,\n--- consulting r.Method, r.Host, and r.URL.Path. It always returns\n--- a non-nil handler. If the path is not in its canonical form, the\n--- handler will be an internally-generated handler that redirects\n--- to the canonical path. If the host contains a port, it is ignored\n--- when matching handlers.\n---\n--- The path and host are used unchanged for CONNECT requests.\n---\n--- Handler also returns the registered pattern that matches the\n--- request or, in the case of internally-generated redirects,\n--- the pattern that will match after following the redirect.\n---\n--- If there is no registered handler that applies to the request,\n--- Handler returns a “page not found” handler and an empty pattern.",
	"httpServeMuxServeHTTP": "--- ServeHTTP dispatches the request to the handler whose\n--- pattern most closely matches the request URL.",
	"httpServeMuxhandler": "--- handler is the main implementation of Handler.\n--- The path is known to be in canonical form, except for CONNECT methods.",
	"httpServeMuxmatch": "--- Find a handler on a handler map given a path string.\n--- Most-specific (longest) pattern wins.",
	"httpServeMuxredirectToPathSlash": "--- redirectToPathSlash determines if the given path needs appending \"/\" to it.\n--- This occurs when a handler for path + \"/\" was already registered, but\n--- not for path itself. If the path needs appending to, it creates a new\n--- URL, setting the path to u.Path + \"/\" and returning true to indicate so.",
	"httpServeMuxshouldRedirectRLocked": "--- shouldRedirectRLocked reports whether the given path and host should be redirected to\n--- path+\"/\". This should happen if a handler is registered for path+\"/\" but\n--- not path -- see comments at ServeMux.",
	"httpServeTLS": "--- ServeTLS accepts incoming HTTPS connections on the listener l,\n--- creating a new service goroutine for each. The service goroutines\n--- read requests and then call handler to reply to them.\n---\n--- The handler is typically nil, in which case the DefaultServeMux is used.\n---\n--- Additionally, files containing a certificate and matching private key\n--- for the server must be provided. If the certificate is signed by a\n--- certificate authority, the certFile should be the concatenation\n--- of the server's certificate, any intermediates, and the CA's certificate.\n---\n--- ServeTLS always returns a non-nil error.",
	"httpServerClose": "--- Close immediately closes all active net.Listeners and any\n--- connections in state StateNew, StateActive, or StateIdle. For a\n--- graceful shutdown, use Shutdown.\n---\n--- Close does not attempt to close (and does not even know about)\n--- any hijacked connections, such as WebSockets.\n---\n--- Close returns any error returned from closing the Server's\n--- underlying Listener(s).",
	"httpServerListenAndServe": "--- ListenAndServe listens on the TCP network address srv.Addr and then\n--- calls Serve to handle requests on incoming connections.\n--- Accepted connections are configured to enable TCP keep-alives.\n---\n--- If srv.Addr is blank, \":http\" is used.\n---\n--- ListenAndServe always returns a non-nil error. After Shutdown or Close,\n--- the returned error is ErrServerClosed.",
	"httpServerListenAndServeTLS": "--- ListenAndServeTLS listens on the TCP network address srv.Addr and\n--- then calls ServeTLS to handle requests on incoming TLS connections.\n--- Accepted connections are configured to enable TCP keep-alives.\n---\n--- Filenames containing a certificate and matching private key for the\n--- server must be provided if neither the Server's TLSConfig.Certificates\n--- nor TLSConfig.GetCertificate are populated. If the certificate is\n--- signed by a certificate authority, the certFile should be the\n--- concatenation of the server's certificate, any intermediates, and\n--- the CA's certificate.\n---\n--- If srv.Addr is blank, \":https\" is used.\n---\n--- ListenAndServeTLS always returns a non-nil error. After Shutdown or\n--- Close, the returned error is ErrServerClosed.",
	"httpServerRegisterOnShutdown": "--- RegisterOnShutdown registers a function to call on Shutdown.\n--- This can be used to gracefully shutdown connections that have\n--- undergone ALPN protocol upgrade or that have been hijacked.\n--- This function should start protocol-specific graceful shutdown,\n--- but should not wait for shutdown to complete.",
	"httpServerServe": "--- Serve accepts incoming connections on the Listener l, creating a\n--- new service goroutine for each. The service goroutines read requests and\n--- then call srv.Handler to reply to them.\n---\n--- HTTP/2 support is only enabled if the Listener returns *tls.Conn\n--- connections and they were configured with \"h2\" in the TLS\n--- Config.NextProtos.\n---\n--- Serve always returns a non-nil error and closes l.\n--- After Shutdown or Close, the returned error is ErrServerClosed.",
	"httpServerServeTLS": "--- ServeTLS accepts incoming connections on the Listener l, creating a\n--- new service goroutine for each. The service goroutines perform TLS\n--- setup and then read requests, calling srv.Handler to reply to them.\n---\n--- Files containing a certificate and matching private key for the\n--- server must be provided if neither the Server's\n--- TLSConfig.Certificates nor TLSConfig.GetCertificate are populated.\n--- If the certificate is signed by a certificate authority, the\n--- certFile should be the concatenation of the server's certificate,\n--- any intermediates, and the CA's certificate.\n---\n--- ServeTLS always returns a non-nil error. After Shutdown or Close, the\n--- returned error is ErrServerClosed.",
	"httpServerSetKeepAlivesEnabled": "--- SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.\n--- By default, keep-alives are always enabled. Only very\n--- resource-constrained environments or servers in the process of\n--- shutting down should disable them.",
	"httpServerShutdown": "--- Shutdown gracefully shuts down the server without interrupting any\n--- active connections. Shutdown works by first closing all open\n--- listeners, then closing all idle connections, and then waiting\n--- indefinitely for connections to return to idle and then shut down.\n--- If the provided context expires before the shutdown is complete,\n--- Shutdown returns the context's error, otherwise it returns any\n--- error returned from closing the Server's underlying Listener(s).\n---\n--- When Shutdown is called, Serve, ListenAndServe, and\n--- ListenAndServeTLS immediately return ErrServerClosed. Make sure the\n--- program doesn't exit and waits instead for Shutdown to return.\n---\n--- Shutdown does not attempt to close nor wait for hijacked\n--- connections such as WebSockets. The caller of Shutdown should\n--- separately notify such long-lived connections of shutdown and wait\n--- for them to close, if desired. See RegisterOnShutdown for a way to\n--- register shutdown notification functions.\n---\n--- Once Shutdown has been called on a server, it may not be reused;\n--- future calls to methods such as Serve will return ErrServerClosed.",
	"httpServercloseIdleConns": "--- closeIdleConns closes all idle connections and reports whether the\n--- server is quiescent.",
	"httpServercloseListenersLocked": "",
	"httpServerdoKeepAlives": "",
	"httpServeridleTimeout": "",
	"httpServerinitialReadLimitSize": "",
	"httpServerlogf": "",
	"httpServermaxHeaderBytes": "",
	"httpServernewConn": "--- Create new connection from rwc.",
	"httpServeronceSetNextProtoDefaults": "--- onceSetNextProtoDefaults configures HTTP/2, if the user hasn't\n--- configured otherwise. (by setting srv.TLSNextProto non-nil)\n--- It must only be called via srv.nextProtoOnce (use srv.setupHTTP2_*).",
	"httpServeronceSetNextProtoDefaults_Serve": "",
	"httpServerreadHeaderTimeout": "",
	"httpServersetupHTTP2_Serve": "--- setupHTTP2_Serve is called from (*Server).Serve and conditionally\n--- configures HTTP/2 on srv using a more conservative policy than\n--- setupHTTP2_ServeTLS because Serve is called after tls.Listen,\n--- and may be called concurrently. See shouldConfigureHTTP2ForServe.\n---\n--- The tests named TestTransportAutomaticHTTP2* and\n--- TestConcurrentServerServe in server_test.go demonstrate some\n--- of the supported use cases and motivations.",
	"httpServersetupHTTP2_ServeTLS": "--- setupHTTP2_ServeTLS conditionally configures HTTP/2 on\n--- srv and reports whether there was an error setting it up. If it is\n--- not configured for policy reasons, nil is returned.",
	"httpServershouldConfigureHTTP2ForServe": "--- shouldDoServeHTTP2 reports whether Server.Serve should configure\n--- automatic HTTP/2. (which sets up the srv.TLSNextProto map)",
	"httpServershuttingDown": "",
	"httpServertlsHandshakeTimeout": "--- tlsHandshakeTimeout returns the time limit permitted for the TLS\n--- handshake, or zero for unlimited.\n---\n--- It returns the minimum of any positive ReadHeaderTimeout,\n--- ReadTimeout, or WriteTimeout.",
	"httpServertrackConn": "",
	"httpServertrackListener": "--- trackListener adds or removes a net.Listener to the set of tracked\n--- listeners.\n---\n--- We store a pointer to interface in the map set, in case the\n--- net.Listener is not comparable. This is safe because we only call\n--- trackListener via Serve and can track+defer untrack the same\n--- pointer to local variable there. We never need to compare a\n--- Listener from another caller.\n---\n--- It reports whether the server is still up (not Shutdown or Closed).",
	"httpSetCookie": "--- SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\n--- The provided cookie must have a valid Name. Invalid cookies may be\n--- silently dropped.",
	"httpStatusText": "--- StatusText returns a text for the HTTP status code. It returns the empty\n--- string if the code is unknown.",
	"httpStripPrefix": "--- StripPrefix returns a handler that serves HTTP requests by removing the\n--- given prefix from the request URL's Path (and RawPath if set) and invoking\n--- the handler h. StripPrefix handles a request for a path that doesn't begin\n--- with prefix by replying with an HTTP 404 not found error. The prefix must\n--- match exactly: if the prefix in the request contains escaped characters\n--- the reply is also an HTTP 404 not found error.",
	"httpTimeoutHandler": "--- TimeoutHandler returns a Handler that runs h with the given time limit.\n---\n--- The new Handler calls h.ServeHTTP to handle each request, but if a\n--- call runs for longer than its time limit, the handler responds with\n--- a 503 Service Unavailable error and the given message in its body.\n--- (If msg is empty, a suitable default message will be sent.)\n--- After such a timeout, writes by h to its ResponseWriter will return\n--- ErrHandlerTimeout.\n---\n--- TimeoutHandler supports the Pusher interface but does not support\n--- the Hijacker or Flusher interfaces.",
	"httpTransportCancelRequest": "--- CancelRequest cancels an in-flight request by closing its connection.\n--- CancelRequest should only be called after RoundTrip has returned.\n---\n--- Deprecated: Use Request.WithContext to create a request with a\n--- cancelable context instead. CancelRequest cannot cancel HTTP/2\n--- requests.",
	"httpTransportClone": "--- Clone returns a deep copy of t's exported fields.",
	"httpTransportCloseIdleConnections": "--- CloseIdleConnections closes any connections which were previously\n--- connected from previous requests but are now sitting idle in\n--- a \"keep-alive\" state. It does not interrupt any connections currently\n--- in use.",
	"httpTransportRegisterProtocol": "--- RegisterProtocol registers a new protocol with scheme.\n--- The Transport will pass requests using the given scheme to rt.\n--- It is rt's responsibility to simulate HTTP request semantics.\n---\n--- RegisterProtocol can be used by other packages to provide\n--- implementations of protocol schemes like \"ftp\" or \"file\".\n---\n--- If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will\n--- handle the RoundTrip itself for that one request, as if the\n--- protocol were not registered.",
	"httpTransportalternateRoundTripper": "--- alternateRoundTripper returns the alternate RoundTripper to use\n--- for this request if the Request's URL scheme requires one,\n--- or nil for the normal case of using the Transport.",
	"httpTransportcancelRequest": "--- Cancel an in-flight request, recording the error value.\n--- Returns whether the request was canceled.",
	"httpTransportconnectMethodForRequest": "",
	"httpTransportcustomDialTLS": "",
	"httpTransportdecConnsPerHost": "--- decConnsPerHost decrements the per-host connection count for key,\n--- which may in turn give a different waiting goroutine permission to dial.",
	"httpTransportdial": "",
	"httpTransportdialConn": "",
	"httpTransportdialConnFor": "--- dialConnFor dials on behalf of w and delivers the result to w.\n--- dialConnFor has received permission to dial w.cm and is counted in t.connCount[w.cm.key()].\n--- If the dial is canceled or unsuccessful, dialConnFor decrements t.connCount[w.cm.key()].",
	"httpTransportgetConn": "--- getConn dials and creates a new persistConn to the target as\n--- specified in the connectMethod. This includes doing a proxy CONNECT\n--- and/or setting up TLS.  If this doesn't return an error, the persistConn\n--- is ready to write requests to.",
	"httpTransporthasCustomTLSDialer": "",
	"httpTransportmaxIdleConnsPerHost": "",
	"httpTransportonceSetNextProtoDefaults": "--- onceSetNextProtoDefaults initializes TLSNextProto.\n--- It must be called via t.nextProtoOnce.Do.",
	"httpTransportputOrCloseIdleConn": "",
	"httpTransportqueueForDial": "--- queueForDial queues w to wait for permission to begin dialing.\n--- Once w receives permission to dial, it will do so in a separate goroutine.",
	"httpTransportqueueForIdleConn": "--- queueForIdleConn queues w to receive the next idle connection for w.cm.\n--- As an optimization hint to the caller, queueForIdleConn reports whether\n--- it successfully delivered an already-idle connection.",
	"httpTransportreadBufferSize": "",
	"httpTransportremoveIdleConn": "--- removeIdleConn marks pconn as dead.",
	"httpTransportremoveIdleConnLocked": "--- t.idleMu must be held.",
	"httpTransportreplaceReqCanceler": "--- replaceReqCanceler replaces an existing cancel function. If there is no cancel function\n--- for the request, we don't set the function and return false.\n--- Since CancelRequest will clear the canceler, we can use the return value to detect if\n--- the request was canceled since the last setReqCancel call.",
	"httpTransportroundTrip": "--- roundTrip implements a RoundTripper over HTTP.",
	"httpTransportsetReqCanceler": "",
	"httpTransporttryPutIdleConn": "--- tryPutIdleConn adds pconn to the list of idle persistent connections awaiting\n--- a new request.\n--- If pconn is no longer needed or not in a good state, tryPutIdleConn returns\n--- an error explaining why it wasn't registered.\n--- tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.",
	"httpTransportuseRegisteredProtocol": "--- useRegisteredProtocol reports whether an alternate protocol (as registered\n--- with Transport.RegisterProtocol) should be respected for this request.",
	"httpTransportwriteBufferSize": ""
}